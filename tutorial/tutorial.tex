\newcommand{\snark}{{\sc SNARK}}
\newcommand{\Snark}{{\sc SNARK\/}}
\newcommand{\specware}{{\sc SPECWARE}}
\newcommand{\Specware}{{\sc SPECWARE}}
\newcommand{\lisp}{{\sc LISP}}
\newcommand{\Lisp}{{\sc LISP}}
\newcommand{\prolog}{{\sc PROLOG}}
\newcommand{\Prolog}{{\sc PROLOG}}
\newcommand{\commonlisp}{{\sc COMMON LISP}}
\newcommand{\Commonlisp}{{\sc COMMON LISP}}
\newcommand{\otter}{{\sc OTTER}}
\newcommand{\Otter}{{\sc OTTER}}
\newcommand{\kif}{{\sc KIF}}
\newcommand{\Kif}{{\sc KIF}}
\newcommand{\okbc}{{\sc OKBC}}
\newcommand{\Okbc}{{\sc OKBC}}
\newcommand{\ansi}{{\sc ANSI}}
\newcommand{\Ansi}{{\sc ANSI}}
\newcommand{\kifsnark}{{\sc KIF}+{\sc C}}
\newcommand{\Kifsnark}{{\sc KIF}+{\sc C}}
\newcommand{\mi}[1]{\mbox{\it #1}}
\newcommand{\false}{{\mbox {\tt false}}}
\newcommand{\varx}{{\mbox {\tt ?x}}}
\newcommand{\vary}{{\mbox {\tt ?y}}}
\newcommand{\varz}{{\mbox {\tt ?z}}}
\newcommand{\varvar}{{\mbox {\tt ?}-variable}}
\newcommand{\dspace}{\renewcommand{\baselinestretch}{1.6}\large\normalsize}
\newcommand{\Complex}{{\tt Complex}}
\newcommand{\Real}{{\tt Real}}
\newcommand{\Rational}{{\tt Rational}}
\newcommand{\Integer}{{\tt Integer}}
\newcommand{\Natural}{{\tt Natural}}
\newcommand{\Positive}{{\tt Positive}}
\newcommand{\Negative}{{\tt Negative}}
\newcommand{\Number}{{\tt Number}}
\newcommand{\Zero}{{\tt Zero}}
\newcommand{\Even}{{\tt Even}}
\newcommand{\Odd}{{\tt Odd}}
\newcommand{\NegativeNumber}{{\tt Negative-Number}}
\newcommand{\PlusInfinity}{{\tt Plus-Infinity}}
\newcommand{\NonNegativeNumber}{{\tt Non-Negative-Number}}
\newcommand{\NegativeInteger}{{\tt Negative-Integer}}
\newcommand{\NonNegativeInteger}{{\tt Non-Negative-Integer}}


\newcommand{\complex}{{\tt complex}}
\newcommand{\real}{{\tt real}}
\newcommand{\rational}{{\tt rational}}
\newcommand{\integer}{{\tt integer}}
\newcommand{\nnatural}{{\tt natural}}
\newcommand{\positive}{{\tt positive}}
\newcommand{\negative}{{\tt negative}}
\newcommand{\nnumber}{{\tt number}}
\newcommand{\zero}{{\tt zero}}
\newcommand{\even}{{\tt even}}
\newcommand{\odd}{{\tt odd}}
\newcommand{\negativenumber}{{\tt negative-number}}
\newcommand{\plusinfinity}{{\tt plus-infinity}}
\newcommand{\nonnegativenumber}{{\tt nonnegative-number}}
\newcommand{\negativeinteger}{{\tt negative-integer}}
\newcommand{\nonnegativeinteger}{{\tt non-negative-integer}}




\newcommand{\sspace}{\renewcommand{\baselinestretch}{1.0}\large\normalsize}
\newcommand{\stars}{\begin{center}
   \mbox{} \\
%%************************** \\
  \mbox{}
 \end{center}}
\baselineskip14pt
\parskip5pt
\parindent0pt
\documentclass[12pt]{article}
%%\usepackage{html}  %% uncomment for html
\pagestyle{headings}
\markright{\Snark\  Guide}
\markright{\Snark\  Guide}
\renewcommand{\baselinestretch}{1.0} %% for double space
\clubpenalty8000\widowpenalty8000
\setcounter{tocdepth}{7}

\begin{document}
%% \begin{rawhtml}
%% <base href="http://www.ai.sri.com/snark/">
%% \end{rawhtml}
\title{A Guide to \Snark}
\author{Mark E. Stickel \and
	Richard J. Waldinger \and
        Vinay K. Chaudhri }

\maketitle
\tableofcontents
\mbox{}
\newpage
\section{Preface}
\label{sec-preface}
 \Snark\/, SRI's New Automated Reasoning Kit, is a theorem prover
 intended for applications in artificial intelligence and software
 engineering.  \Snark\  is geared toward dealing with large sets of
 assertions; it can be specialized with strategic controls that tune
 its performance; and it has facilities for integrating
 special-purpose reasoning procedures with general-purpose inference.

 \Snark\  has been used as the reasoning component of SRI's High
 Performance Knowledge Base (HPKB) system, which deduces answers to
 questions based on large repositories of information.  It constitutes
 the deductive core of the NASA Amphion system, which composes
 software from components to meet users' specifications, e.\ g., to
 perform computations in planetary astronomy.  \Snark\  has also been
 connected to Kestrel's \specware\  environment for software
 development.

\Snark\  is a resolution-and-paramodulation theorem prover for
first-order logic with equality---in this sense, it is in the same
category as Argonne's \otter\/ (\cite{otter}).
\Snark\  has provisions for both clausal and nonclausal reasoning, and
it has an optional sort mechanism.  It incorporates associative/commutative
unification and a built-in decision procedure for reasoning about temporal
points and intervals.  It has no special facilities for proof by mathematical
induction.  It has some capabilities for abductive reasoning, which have been
used in natural-language applications.
\Snark\  is implemented in an easily portable subset of \commonlisp\/.

\Snark\  is a refutation system; in other words, rather that trying to
show directly that some assertions imply a desired conclusion, it attempts to
show that the assertions and the negation of the conclusion imply a
contradiction.  It is an agenda-based system; that is, in seeking a
refutation, it will put the assertions and the negation of the conclusion on
an agenda. An agenda is a list of formulas.  When a formula reaches the top of
the agenda, \snark\  will perform selected inferences involving that formula
and the previously processed formulas.  The consequences of those inferences
are added to the agenda.  This process continues until the propositional
symbol
\false\  is derived; this means that a contradiction has been deduced
and the refutation is complete.  The user has considerable control
over the position at which a newly derived formula is placed on the
agenda; this is one way in which a knowledgeable user can tailor
\snark\/'s search strategy to a particular application.

 This document is an example-driven tutorial introduction to
\snark\  that will allow the reader to experiment with the system.
It does not purport to introduce mathematical logic or resolution theorem
proving; \cite{chang} provides an introduction to this style of theorem
proving that does not assume any prior knowledge of logic.  The guide also
uses some notions introduced more fully in \cite{manna} and
\cite{waldinger}, particularly nonclausal resolution, quantifier
force, and answer extraction.  Knowledge of \lisp\  syntax and basics
is also assumed here (e.\ g., see \cite{ansi-commonlisp} or
\cite{commonlisp-hyperspec}).  Nevertheless, it is intended that a
reader who is willing to suspend incomprehension will be able to
read this document without consulting other sources.

%%The second part of the guide is a reference manual, which gives a more
%%systematic introduction to the \snark\  language and features.

The guide is divided into several sections.  In Getting Started
(Section \ref{sec-getting-started}) we give the minimum information
necessary to allow a user to get started with \snark\/.  We show how
to enter axioms, and pose questions and set \snark\ parameters.  In
Language and Logic (Section \ref{sec-language-and-logic}) we introduce
the aspects of the \snark\  language, including sorts, equality, and
quantifiers, and we discuss mechanisms for dealing with them,
including the paramodulation rule and skolemization.  In Section
\ref{sec-answer-extraction}, Topics in Answer Extraction, we discuss
how \snark\  is used to provide answers to questions (other than a
simple Yes), and how answers are managed.  In Efficiency
Considerations (Section
\ref{sec-efficiency-considerations}) we describe \snark\  features that
help us direct the search, to find an answer more quickly.

In Temporal Reasoning (Section \ref{sec-temporal-reasoning}) we describe the
feature that allows \snark\  to reason efficiently about temporal points and
intervals.  In Procedural Attachment (Section
\ref{sec-procedural-attachment}) we talk about how \snark\  can do inferences
using special-purpose external procedures supplied by the user.  In Support
for \kif\//\okbc\   Users  (Section \ref{sec-kif-snark}) we describe
\kifsnark\/ (\kif\  plus Classes), the facility that enables \snark\  to
understand assertions and queries phrased in \kif\/, the Knowledge
Interchange Format, with some extensions from \okbc\ (``Open
Knowledge-Base Connectivity''), an object-oriented framework for
representing knowledge.  This dialect was used in the HPKB project
and other knowledge representation efforts.

In future versions of this guide we intend to include a description of
\snark's abduction mechanism, a reference manual, and a description of
\snark's internal workings.  The guide is meant to be a living document, that
will change as \snark\  develops.

%%In Abduction (Section
%%\ref{sec-abduction}) we introduce the abduction package.

%%The tutorial currently contains no description of
%%the temporal reasoning package or other methods for attaching procedures to
%%particular function and predicate symbols, so that certain inferences can be
%%performed by special-purpose algorithms.  Also we do not describe the
%%facility that enables \snark\  to
%%These will be included in future editions of
%%this document.
%%In Section
%% \ref{sec-kif-snark} (\Snark\  through \Kif\/) we discuss how \snark\
%% can reason from knowledge bases represented in \kif\/, the Knowledge
%% Interchange Format used in the HPKB project and other knowledge
%% representation efforts.


%%\part{A \snark\  Tutorial}

\label{part-tutorial}
\section{Getting Started}
\label{sec-getting-started}
In this section, we give minimum information necessary to get
started with \snark.


\subsection{\Snark\  language and theories}
\label{subsec-language-and-theories}
We begin by introducing the language of \snark\  and then show how to describe
subject matter as a logical theory.  As a running example in this document,
we illustrate of the use of \snark\  to reason in a theory of family
relationships.

\subsubsection{The \Snark\  language}


{\em Terms} stand for entities, such as things and people, while {\em
formulas} stand for truth-values, either true or false.  {\em Constants},
such as {\tt carol} and {\em variables}, such as
\varx\/, are terms.  A constant such as \verb'betty'
or \verb'carol'  refers to only one thing, while a variable may refer to
different things, depending on context.  (Note that \snark\  is usually
case-insensitive;  it will not distinguish between the constants
\verb'carol', \verb'CAROL', and \verb'CaRoL'.)

Function symbols, such as \verb'father' and \verb'mother', can be applied to
a term to yield another term, such as \verb'(father carol)' and
\verb'(mother ?x)', standing for the father of Carol and the mother of \varx\/,
respectively.  Because these function symbols take only one argument, we say
that are {\em unary}, or of {\em arity} 1.

Predicate symbols, such as \verb'parent' or \verb'grandparent', are applied
to terms but yield {\em atoms}, which are elementary formulas, not terms.
Thus
\begin{verbatim}
  (parent carol ?x)
\end{verbatim}
is an atomic formula that stands for a
truth-value, which is true if Carol is indeed a parent of \varx\/, and false
otherwise.  Predicate symbols stand for a relation between entities;
\verb'parent' stands for the parenthood relation.  Because \verb'parent' and
\verb'grandparent' take two arguments, we say they are {\em binary} predicate
symbols, of arity 2.  There are also {\em propositional} symbols, such as
{\tt it-is-raining}, which are themselves atoms, and can be either true or
false.  Finally, there are two special propositional symbols, the {\em truth
symbols}
\verb'true' and \verb'false', which always stand for the truth-values true
and false, respectively.


Other formulas are built up from atoms by successive application of
logical {\em connectives} (\verb'and', \verb'or', \verb'not',
\verb'implies',
\verb'implied-by', \verb'iff', {\tt xor} {\tt nand}, and {\tt nor}), the {\em universal quantifier}
\verb'forall' and the {\em existential quantifier} \verb'exists'.
Various synonyms are accepted for these symbols.

Thus, if \verb'<Form1>' and \verb'<Form2>' are formulas, so are
\begin{verbatim}
  (and <Form1> <Form2>)

  (exists (?x) <Form1>)
\end{verbatim}
and so forth.  For example,
\begin{verbatim}
  (forall (?x)
   (implies
    (parent ?x (mother carol))
    (grandparent ?x carol)))
\end{verbatim}
is a formula, which means that anyone who is a parent of the mother of Carol
is a grandparent of Carol.  (In the theory we have in mind, this formula
stands for the truth-value true.)  We will say that the occurrences of \varx\
in the above formula are {\em bound} by the quantifier
\verb'(forall(?x)...)'.
Variable occurrences that are not bound by any quantifier are said to be {\em
free}.

Any symbol in the list following a quantifier is taken to be a variable,
whether or not it is prefixed by \verb'?'.  Thus, the above formula could
just as well have been written
\begin{verbatim}
  (forall (x)
   (implies
    (parent x (mother carol))
    (grandparent x carol)))
\end{verbatim}
An occurrence of \verb'x' not bound by a quantifier is
taken to be a constant, while any symbol prefixed by \verb'?' is
automatically a variable, whether or not it is bound by a quantifier;
we call these {\em ?-variables}.

Together, terms and formulas make up the {\em expressions}.  No expression is
both a term and a formula.  A string of symbols, such as
\begin{verbatim}
  (father (parent ?y carol))
\end{verbatim}
obtained by applying a function symbol to a formula is not a legal expression
in the \snark\  language.

\subsubsection{\Snark\  Theories}

A {\em theory}, then is a vocabulary of constant, function, and predicate
symbols, and a set of formulas, called {\em assertions}, which describe the
properties of the entities mentioned in the theory.  For example, in the
family theory we are discussing, we can introduce the assertion
\begin{verbatim}
  (parent betty carol)
\end{verbatim}
to say that Betty is a parent of Carol.

The fact that fathers and mothers are parents is expressed by the two \snark\
assertions
\begin{verbatim}
  (forall (?x) (parent (father ?x) ?x))

  (forall (?x) (parent (mother ?x) ?x))
\end{verbatim}
In other words, the father of {\tt ?x} is a parent of {\tt ?x}, and the
mother of {\tt ?x} is a parent of {\tt ?x}.

There is a convention that, in assertions, free ?-variables \varx\  are actually
bound by an invisible universal quantifier \verb'(forall (?x)...)'.  Thus, the
above assertions could have been written
\begin{verbatim}
  (parent (father ?x) ?x)

  (parent (mother ?x) ?x)
\end{verbatim}
Had we used variables without question-marks, however, we could not have
omitted the quantifier \verb'(forall (x)...)'; \verb'x' would have been taken to
be a constant.

The fact that a parent of a parent is a grandparent is expressed by
the following \snark\  assertion:
\begin{verbatim}
  (implies
   (and (parent ?x ?y) (parent ?y ?z))
   (grandparent ?x ?z))
\end{verbatim}
That is, if ?x is a parent of ?y, and ?y is a parent of ?z, then ?x is
a grandparent of ?z.

Once we have formulated a theory, we can pose a {\em query}, which is a
\snark\  formula treated as a question rather than an assertion.
\Snark\  will attempt to show that a query follows from all the assertions of
the theory.
For example, if we want to ask if Carol has a grandparent, we may pose the
query
\begin{verbatim}
 (exists (?z) (grandparent ?z carol))
\end{verbatim}
In other words, we want to deduce that there exists \varz\  such that \varz\
is a grandparent of Carol.

The convention for queries is the opposite of that for assertions.  In a
query, a free ?-variable \varz\  is bound by an invisible existential quantifier
\verb'(exists (?z)...)'.  Thus, the above query could have been written
\begin{verbatim}
  (grandparent ?z carol)
\end{verbatim}

In attempting to prove this query, \snark\  will assert the negation of the
query and attempt to derive a contradiction from that and the other
assertions.  Thus, \snark\  will assert
\begin{verbatim}
  (not (grandparent ?z carol))
\end{verbatim}
and attempt to deduce the truth symbol \verb'false'.  If it succeeds, we know
that all the assertions together must be contradictory.


\subsubsection{Clauses}
\Snark\  is more efficient
when dealing with formulas in {\em clausal form.}
A {\tt clause} is a special kind of formula that consists of a
disjunction of {\tt literals}, where each literal is either an atom or
the negation of an atom.  For instance, the formula
\begin{verbatim}
  (or
   (not (parent ?person ?person1))
   (not (parent ?person1 ?person2))
   (grandparent ?person ?person2))
\end{verbatim}
is in clausal form; it is the disjunction ({\tt or}-ing) of three literals:
one atom and two negations of atoms.  This clause is equivalent to the
assertion that the parent of a parent is a grandparent.  Much resolution
theorem proving is based on the fact that the problem of refuting any formula
is equivalent to one of refuting a formula that is in clausal form, i.\ e.,
that consists of a conjunction ({\tt and}-ing) of clauses.  As its default,
\snark\  translates all formulas into clausal form, which it can deal with
most efficiently.

\subsection{Resolution}
\label{subsec-resolution}

In searching for a refutation, \snark\  will apply the resolution rule
to the formulas on its agenda.  In its simplest form, the rule can be
applied to two given clauses of form
\begin{verbatim}
  (or (not P) Q)
\end{verbatim}
and
\begin{verbatim}
  (or P R)
\end{verbatim}
and will deduce the corresponding clause of form
\begin{verbatim}
  (or Q R)
\end{verbatim}
But the rule is more complex than that.  The two given clauses do not
need to have identical subatoms {\tt P}. It is enough if the
subatoms are {\em unifiable}---in other words, if one can make them
identical by applying a substitution, replacing their
variables by other terms.

The order of the disjuncts is irrelevant; \verb'(not P)' and {\tt P}
do not need to be first.
Also it is possible that either or both of the other subformulas {\tt
Q} and {\tt R} are actually several disjuncts.  Or they may be absent
(i.\ e., one or both may be taken to be {\tt false}); the given formulas
are then simply {\tt (not P)} or {\tt P}, respectively, and the
deduced formula will then be {\tt R} or {\tt Q}, respectively.  If
both {\tt Q} and {\tt R} are absent, the deduced formula is {\tt
false}, and the refutation is complete.

We shall see an application of the resolution rule in the following
section.
\subsection{Invoking \Snark }
\label{subsec-invoking-snark}
Let us see how to invoke \snark\  to solve the above problem.

We start with a \lisp\  environment and load the \snark\  system; how to
do this depends on your particular installation.  We start by typing:
\begin{verbatim}
  (initialize)
  (use-resolution t)
\end{verbatim}
The {\tt initialize} function will clear out any previous
formulas \snark\  has derived and ready it to accept a new theory and
perform a new proof.  After initialization, we indicate which
inference rules we would like to use, in this case resolution.

We then introduce the assertions of our theory as \snark\  assertions:
\begin{verbatim}
  (assert '(parent (father ?x) ?x) :name 'father-is-parent)

  (assert '(parent (mother ?x) ?x) :name 'mother-is-parent)

  (assert
   '(implies
     (and (parent ?x ?y) (parent ?y ?z))
     (grandparent ?x ?z))
   :name 'parent-of-parent-is-grandparent)
\end{verbatim}
Note that each assertion is given a name, a string that follows the {\em
keyword} {\tt :name}; these names have no effect on the proof, but will be
used in the trace to indicate where the assertion is used.  If the name is
omitted, a number will be used instead.  The assertion, its name or number,
and some other information are stored in a structure called a ``row.''

A query is initiated by the \snark\ {\tt prove} function:
\begin{verbatim}
  (prove '(grandparent ?z carol)
          :name 'does-carol-have-a-grandparent)
\end{verbatim}
Here we have given the query a name, for our own convenience in
following the proof.

The query has the effect of putting the negation of the formula
\begin{verbatim}
  (grandparent ?z carol)
\end{verbatim}
into a row and then invoking \snark\  to find a refutation.

\Snark\  will respond by first giving a list of the options that have
been selected.  Some of these (e.\ g., resolution) we have selected;
most of them are defaults:
\begin{verbatim}
; The current SNARK option values are
;       (USE-RESOLUTION T)
;       (USE-HYPERRESOLUTION NIL)
; ...
\end{verbatim}
This means that we have selected to use resolution and not
hyperresolution.  (Hyperresolution is a variant of
resolution that can do several resolution steps at once and is often
more efficient.) \Snark\  will print out a complete list of the
options it offers, and the settings that have been selected.  If the
user has not selected a setting, \Snark\  will choose the default.
This printing, and the other printing reported here, can be altered by
the user---we are reporting \Snark 's default behavior.

 \Snark\  will then print out the assertions it has been given, and the
negation of the conclusion:
\begin{verbatim}
(Row father-is-parent
   (parent (father ?x) ?x)
   assertion)
(Row mother-is-parent
   (parent (mother ?x) ?x)
   assertion)
(Row parent-of-parent-is-grandparent
   (or (not (parent ?x ?y)) (not (parent ?y ?z))
       (grandparent ?x ?z))
   assertion)
(Row does-carol-have-a-grandparent
   (not (grandparent ?x carol))
   ~conclusion)
\end{verbatim}

For each row, \snark\  provides its name or number, its formula, and an
explanation of its origin.  \Snark\  freely renames variables according
to its own conventions---thus, in the negation of the conclusion, the
variable \varz\  has been renamed \varx\/. \snark\  provides control
options to suppress the printing of formulas.

Next, \snark\  gives an account of the steps it takes in searching for
the proof.  If it finds a refutation, it will then reprint only those
rows that play a role.
Here is the first of these steps:
\begin{verbatim}
(Row 12
   (or (not (parent ?x ?y))
       (not (parent ?y carol)))
   (resolve does-carol-have-a-grandparent
            parent-of-parent-is-grandparent))
\end{verbatim}
Note that the row contains some information about how its formula was
deduced, if it was not an assertion or the negation of the conclusion.
Here Row 12 was obtained by applying the resolution rule to the
negation of the conclusion and the assertion that the parent of a
parent is a grandparent.  The unifying substitution replaced the
variable \varz\  with the constant {\tt carol}; this substitution is
reflected in Row 12.

Here is the next step:
\begin{verbatim}
(Row 23
   (not (parent ?x carol))
   (resolve 12 father-is-parent))
\end{verbatim}
Note that the fact that \varx\  occurs in both Row 12 and in the
assertion {\tt father}-{\tt is}-{\tt parent} is not logically
significant---variables are systematically renamed before unification
to avoid such coincidences.  Otherwise the two rows would not be
unifiable

Finally, we obtain
\begin{verbatim}
(Row 24
   false
   (resolve 23 father-is-parent))
\end{verbatim}
The formula {\tt false} indicates that a refution has been obtained.
The intuitive idea behind this proof is that Carol's father is her
parent, Carol's father's father is {\em his} parent, and, since the
parent of a parent is a grandparent, Carol's father's father is her
grandparent.

\Snark\  will then report on statistics involved in the proof search,
e.\  g.:
\begin{verbatim}
; Summary of computation:
;     15 formulas have been input or derived (from 7 formulas).
;     12 (80%) were retained.  Of these,
;         1 ( 8%) were simplified or subsumed later,
;         0 ( 0%) were deleted later because
                  the agenda was full
;        11 (92%) are still being kept.
;
; Run time in seconds excluding printing time:
;      0.01   5%   Resolution
;      0.01   5%   Forward subsumption
;      0.17  89%   Other
;      0.19        Total
; ....
\end{verbatim}
To conclude, \snark\  will return a value,
\begin{verbatim}
:PROOF-FOUND
\end{verbatim}

If the desired conclusion does not follow from the assertions, \Snark\
will fail to find a proof. There are two ways it may behave in this
case.  It may exhaust all possible inferences without finding a
refutation; in this case it will report that the agenda is empty, and
halt, reporting
\begin{verbatim}
; All agendas are empty.
:AGENDA-EMPTY
\end{verbatim}
Or it may continue to run on indefinitely without ever finding
a refutation.

For instance, if we do not give \Snark\  the assertion that the parent of a
parent is a grandparent, \Snark\  will print the two assertions and the
negation of the conclusion, give the statistical summary, and then
halt with an empty agenda.
In this configuration \snark\  is a {\em logically complete} theorem
prover; that is, if conclusion does follow from the assertions,
\snark\  will find a proof.  Therefore, we know that in this case the
assertions do not imply the conclusion.

On the other hand, if \snark\  runs on for longer than we expect, there
is no way, in general, to determine if the conclusion is not valid or
if we simply haven't given it enough time.  This is not a particular
weakness of \snark\/; it is a theoretical limitation on all theorem
provers that are logically complete for first-order logic or more
expressive logics.

If \snark\  is running longer than we expect, we may interrupt it by
typing a carriage return at the keyboard.  (In most implementations we
may type any character for this purpose.)  \Snark\  will then ask
\begin{verbatim}
  Stop now?
\end{verbatim}
We may answer {\tt yes}, meaning to interrupt the proof, or {\tt no},
meaning to continue the proof.  Even if we choose to interrupt the
proof, we may continue later by calling the function \verb|(closure)|,
the \snark\  function that computes the logical consequences of the
current set of rows.  This function is also invoked automatically when
we call {\tt prove}.  We say more about calling it explicitly in
Section \ref{subsec-multiple-answers}.


Now let us see how to change \snark\/'s strategies and options.
\label{subsec-select-option}

We indicated that \snark\  was to use the (binary) resolution rule by
executing
\begin{verbatim}
  (use-resolution t)
\end{verbatim}
after calling \verb|initialize| but before calling
\verb|prove|.  If we change our mind and decide to try hyperresolution
instead, we can invoke
\begin{verbatim}
  (use-resolution nil)
  (use-hyperresolution t)
\end{verbatim}
before starting the proof.

\label{clausification}
We have mentioned that clause form is the default for \snark\/.  If we
decided to try using nonclausal resolution instead, we may say
\begin{verbatim}
  (use-resolution t)
  (use-clausification nil)
\end{verbatim}
after initialization but before beginning the proof.  In this case,
\snark\  will invoke a nonclausal version of the resolution rule.
(Caution: no nonclausal version of hyperresolution has been
implemented. )

This illustrates a pattern with setting \snark\  options.
Henceforth, when we say that we select \snark\  option {\tt
some-option}, we shall mean that we execute
\begin{verbatim}
  (use-some-option t)
\end{verbatim}
after initializing \snark\  but before beginning the proof.   As an
abbreviation, we may simply say
\begin{verbatim}
  (use-some-option)
\end{verbatim}
to select {\tt some-option}.  To turn the option off, we say
\begin{verbatim}
  (use-some-option nil)
\end{verbatim}
Most of the options that \snark\  lists when it begins a proof can be
turned on or off in this manner.

If we want to ask \snark\  what its setting is for a particular option
{\tt some-option},
we may invoke
\begin{verbatim}
  (use-some-option?)
\end{verbatim}
For instance, if we want to see if \snark\  is currently using the
resolution rule, we invoke
\begin{verbatim}
  (use-resolution?)
\end{verbatim}

Invoking {\tt ini}\-{\tt tial}\-{\tt ize}  causes \snark\  to revert to
its default options.   Later (in Section \ref{subsec-change-default}),
we shall see how to change those defaults.

\paragraph{Exercise: Resolution versus Hyperresolution.}
Run \snark\  on the problem of finding the grandparents of Carol;
compare its performance using resolution and hyperresolution. Also
compare the results using the clausal and the nonclausal versions of
resolution.  See what happens if you request the nonclausal
version of hyperresolution, nonexistent at the time of this writing.

The following section, on how to change \snark\/'s default behavior, may be
omitted on first reading.

\subsection{Changing \Snark\/'s Defaults}
\label{subsec-change-default}



Each time we initialize \snark\/, we restore the setting of all its
options to its defaults.  We have seen how, after initialization, we
can reset \snark\/'s options.  This is appropriate if we want to
change \snark\/'s behavior for a particular query, but want it to
resume its normal behavior subsequently, the next time it is
initialized.  If we want a more permanent change, it is convenient to
change \snark\/'s default behavior; there is a convention about how to go
about this.

Here is an example: as we have seen, use of the resolution rule is not
the default in \snark\/; if we want to turn it on, we must say
\begin{verbatim}
  (use-resolution t)
\end{verbatim}
after initializing \snark\  and before beginning the proof.  Subsequent
calls to \verb|(initialize)| will restore the default, i.\  e., will turn
resolution back off.  If we normally do want to use resolution (as
opposed to hyperresolution, say), we can change \snark\/'s default; we may
invoke
\begin{verbatim}
  (default-use-resolution t)
\end{verbatim}
This in itself will not change \snark\/'s setting on the resolution
option, but subsequent invocation of {\tt initialize} will then turn
on resolution.  Thus, typically, we will set the default before we
invoke initialize.

In general, calling
\begin{verbatim}
  (default-use-some-option ...)
\end{verbatim}
changes the default setting for {\tt some-option}.  Calling {\tt initialize}
returns \snark\  to its default setting for all options.  Calling
\begin{verbatim}
  (use-some-option ...)
\end{verbatim}
changes the setting for {\tt some-option} temporarily, without changing the
default.  Subsequent calls to {\tt initialize} return the setting to
its default again.  This enables us to experiment with different
settings for the options without changing the default.

\subsection{Basic Answer Extraction}
\label{subsec-basic-answer-extraction}
In the example of Section \ref{subsec-invoking-snark}, we have
established that Carol has at least one grandparent, but we have not
answered the question ``Who is Carol's grandparent?''  For this
purpose, we may use \snark\/'s answer-extraction mechanism.  We
include in the {\tt prove} statement an indication of what constitutes
an answer, should the proof succeed:
\begin{verbatim}
  (prove '(grandparent ?z carol) :answer '(ans ?z))
\end{verbatim}
Notice that we have given our query a new component, {\em the answer
formula}, which follows the keyword {\tt :answer}.  This means we are asking
\snark\ to tell us what value of \varz\ will allow us to show that \varz\ is
Carol's grandfather.  In response, \snark\ proves the conclusion again,
reporting in each row what substitution was made for \verb'(ans ?z)' at that
stage of the proof:
\begin{verbatim}
(Refutation
(Row father-is-parent
   (parent (father ?x) ?x)
   assertion)
(Row parent-of-parent-is-grandparent
   (or
    (not (parent ?x ?y))
    (not (parent ?y ?z))
    (grandparent ?x ?z))
   assertion)
(Row does-carol-have-a-grandparent
   (not (grandparent ?x carol))
   ~conclusion
   Answer (ans ?x))
(Row 12
   (or (not (parent ?x ?y)) (not (parent ?y carol)))
   (resolve
     does-carol-have-a-grandparent
     parent-of-parent-is-grandparent)
   Answer (ans ?x))
(Row 23
   (not (parent ?x carol))
   (resolve 12 father-is-parent)
   Answer (ans (father ?x)))
(Row 30
     false
     (resolve 23 father-is-parent)
     Answer (ans (father (father carol))))
\end{verbatim}
At Row 23, we see that if \varx\  is a parent of Carol, then the father
of \varx\  is a suitable answer (that is, \varx\  is a grandparent of
Carol.)  At the end of the proof, we see that the father of the father
of Carol is a grandparent of Carol.  Later (Section
\ref{subsec-multiple-answers}), we shall see how to obtain more than
one answer for a given query.

Use of the predicate symbol {\tt ans} is arbitrary; we can give any
formula as the answer formula.   We could not, however, say simply
\begin{verbatim}
  (prove '(grandparent ?z carol) :answer '?z)
\end{verbatim}
because the answer must be a formula, not a term.


This concludes the Getting Started section, which acquaints the user
with the bare minimum necessary to experiment with the system.  We now
give a more detailed introduction to \snark\/.

\section{Language and Logic}
\label{sec-language-and-logic}

In this section we give additional \snark\  language constructs and the
mechanisms it has for dealing with these constructs.  We include the syntax
of symbols, the
sort mechanism, equivalence, equality, and quantifiers.

\subsection{The Syntax of Symbols}
\label{subsec-symbol-syntax}
The syntax of the basic \snark\  symbols can be described as follows.

A {\em proposition symbol}, {\em predicate symbol}, or {\em function symbol}
can be any \lisp\   symbol that
\begin{itemize}
\item is at least one character long,
\item does not begin with the character ``{\tt ?}'',
\item is not the symbol {\tt NIL},
\item is not the (keyword) symbol {\tt :none}, and
\item is not another keyword symbol, such as {\tt :name} or {\tt :answer}.
\footnote{Unless \snark\  option
{\tt allow-keyword-proposition-symbols},
{\tt allow-keyword-predicate-symbols}, or
{\tt allow-keyword-function-symbols} is true.}
\end{itemize}

A {\em constant symbol}
can be a \lisp\   number, character, string,
or any \lisp\   symbol that
\begin{itemize}
\item is at least one character long,
\item does not begin with the character ``{\tt ?}'',
\item is not the (keyword) symbol {\tt :none}, and
\item is not another keyword symbol.
\footnote{Unless \snark\  option
{\tt allow-keyword-constant-symbols} is true.}
\end{itemize}
\Snark\  compares constant symbols using the \lisp\   {\tt EQL} function.
Thus, {\tt 3} and {\tt 3.0} are different constant symbols.
Ordinarily, {\tt (EQL "ABC" "ABC")} may be false, but \snark\  will
use a single copy of string constants so that such tests will succeed.

A {\em variable symbol}
can be any \lisp\   symbol that
\begin{itemize}
\item is at least two characters long,
\item begins with the character ``{\tt ?}'', and
\item is not a keyword symbol.
\end{itemize}
A variable symbol bound by a quantifier
can also be any \lisp\   symbol that
\begin{itemize}
\item is at least one character long,
\item does not begin with the character ``{\tt ?}'',
\item is not the symbol {\tt NIL}, and
\item is not a keyword symbol.
\end{itemize}
Whether {\tt X} is a variable symbol or a constant symbol
depends on whether the occurrence of {\tt X} is bound (or being bound) by
a quantifier or not.


\subsection{Sorts}
\label{subsec-sorts}

Sorts provide a mechanism to restrict the possible instantiations of a
variable in a formula.  Sorts can substantially reduce the cost of
inference by restricting the search space.  Using sorts some formulas
can be stated more compactly.

In our theory of family relationships, everything is tacitly assumed
to be a person.  If an assertion has a global variable \varx\/, that
variable is assumed to stand for a person, but that assumption has not
been made explicit.

If we were to combine this theory with another theory of, say,
inanimate objects, we would have to differentiate between those assertions
that are meant to apply to people and those that are meant to apply
to objects.  For example, the assertion that says that everyone's father
is his parent holds only for people, not objects.

We could do this by introducing predicate symbols \verb'person' and
\verb'object', and augmenting our axioms with antecedents that classify the
variables.  For instance, our axiom that fathers are parents could be written
\begin{verbatim}
  (assert
   '(implies
     (person ?x)
     (parent (father ?x) ?x))
   :name 'father-is-parent)
\end{verbatim}
However, such axioms are more cumbersome to write, particularly if they
 contain many variables.  Moreover, including conditions such as
 \verb'(person ?x)' makes proofs longer and, consequently, more difficult to
 find.  Every time \snark\   uses the axiom to prove that a term
\verb'(father <term>)' is a parent, it must prove \verb'(person <term>)'.

 In fact, we might
wish to limit the {\tt parent} and {\tt father} symbols so that their
arguments are forced to be people.  We might choose to make it illegal
to write an assertion that mentioned \verb|(father the-maltese-falcon)|,
since {\tt the-maltese-falcon} is not a person.

The sort mechanism achieves this by introducing new symbols, called {\em
sorts}, which stand for nonempty sets of entities.  The terms of our
vocabulary are classified as being {\em of} certain sorts.

For instance, we may introduce two new sorts, {\tt person} and
{\tt object}, standing for sets of people and inanimate objects,
respectively, by the declarations
\begin{verbatim}
  (declare-sort 'person)
  (declare-sort 'object)
\end{verbatim}
If a term is of sort \verb'person', that means that it must stand for a
person.

The intersection of two sorts is assumed to be nonempty unless we deny it
explicitly.  For instance, to say that no one is both a person and an object,
we must say
\begin{verbatim}
  (declare-disjoint-sorts 'person 'object)
\end{verbatim}
(If we make this declaration, we may omit the first two.) Otherwise, \snark\
will assume that some entity is both a person and an object.

Let us suppose that we want a richer sort structure; we want to
introduce sorts for men and women as well as people.  Then, instead of
(or in addition to) the earlier declaration for {\tt person}, we could
provide
\begin{verbatim}
  (declare-subsorts 'person 'man 'woman)
\end{verbatim}
This means that {\tt person} has subsorts {\tt man} and {\tt woman};
every term of sort {\tt man} is also of sort {\tt person}, and
similarly for {\tt woman}.

Finally, if we want to say that {\tt man} and {\tt woman} are a
disjoint partition of {\tt person}, we can say
\begin{verbatim}
  (declare-sort-partition 'person 'man 'woman)
\end{verbatim}
This means that not only are {\tt man} and {\tt woman} disjoint
subsorts of {\tt person}, but also that every term of sort {\tt
person} must be either of sort {\tt man} or of sort {\tt woman}.

It is also possible to use boolean operators to define new sorts or to
express relationships between sorts.  For example, if we want to
introduce a new sort that includes objects and men, we can say
\begin{verbatim}
  (declare-sort 'object-or-man :iff '(or object man))
\end{verbatim}
This means that every term of sort {\tt object-or-man} is of sort {\tt
object} or of sort {\tt man}, and every term that is of one of these
two sorts is also of sort {\tt object-or-man}.
Other boolean operators, such as {\tt and} and {\tt not}, may also be
used.  \Snark\  is able to deduce relationships between sorts declared
in this way.  For instance, it will know that the sort {\tt
object-or-man} is the same as the sort {\tt same-sort} declared by
\begin{verbatim}
  (declare-sort 'same-sort
                :iff '(and (or object person) (not woman)))
\end{verbatim}
In this way, \snark\/'s sort mechanism is unusually versatile.

Once we have established a sort structure, we can classify our
vocabulary accordingly.  For instance, we can declare Bob to be a man,
Carol to be a woman, and the-maltese-falcon to be an object:
\begin{verbatim}
  (declare-constant-symbol 'bob :sort 'man)
  (declare-constant-symbol 'carol :sort 'woman)
  (declare-constant-symbol 'the-maltese-falcon :sort 'object)
\end{verbatim}
Here {\tt declare-constant-symbol} is a \lisp\  function whose
value is the declared symbol.

Because we have declared that {\tt man} and {\tt woman} are
disjoint sorts, this also means that {\tt bob} is not of sort {\tt
woman} and {\tt carol} is not of sort {\tt man}.  Because both {\tt
man} and {\tt woman} are subsorts of {\tt person}, and because we have
declared that {\tt person} and {\tt object} are disjoint, this means
further that neither {\tt bob} nor {\tt carol} can be of sort {\tt
object}.

We can declare the function symbol {\tt father} to take a person as an
argument and yield a man as a value, as follows:
\begin{verbatim}
  (declare-function-symbol 'father 1 :sort '(man person))
\end{verbatim}
Note that for the declaration of a function, the sort for the value of the
function comes before the sorts of its arguments.  This declaration must be
made before we use the symbol {\tt father} in an assertion or conclusion.
Also, it is required to include the number of arguments (arity) {\tt 1} in
the declaration, because if {\tt father} is sometimes used with more than one
argument, those occurrences stand for different functions.  A separate
declaration could be given for a two-argument symbol {\tt father}, with
different sorts for its arguments.

If we want to give a function or relation an alternative name, we use the
{\em alias} mechanism.  For instance, we can give the one-argument function
{\tt father} the alternative name {\tt father-1} by providing a declaration
\begin{verbatim}
  (declare-function-symbol 'father 1 :sort '(man person)
    :alias 'father-1)
\end{verbatim}
Then we can use the name {\tt father-1} when we need to refer unambiguously
to the one-argument father.  The two-argument {\tt father} could be given the
alias {\tt father-2}.  Usually, however, we do not need to distinguish
between them because \snark\  can see how many arguments are provided.
In the trace of the proof, both functions will be represented as {\tt
father}.

The fact that the predicate symbol {\tt parent} takes two arguments of
sort {\tt person} is expressed in its declaration:
\begin{verbatim}
  (declare-predicate-symbol 'parent 2
    :sort '(boolean person person))
\end{verbatim}
Note that predicate symbols are declared as if they were function
symbols that return a value of sort {\tt boolean}.




It is also possible to declare the sorts of variables, such as
\begin{verbatim}
  (declare-variable-symbol '?some-guy :sort 'man)
\end{verbatim}
If an assertion or query contains free (unquantified) occurrences of the
variable \verb'?some-guy', they will then automatically be of sort
\verb'man'.

If a formula contains explicit quantifiers, we can declare the sort of a
variable within the quantifier itself.  For example, in a formula
\begin{verbatim}
  (forall ((?this-man :sort man)
        (?that-man :sort man)) ...)
\end{verbatim}
the variables \verb'?this-man' and \verb'?that-man' are of sort \verb'man'.

Symbols such as {\tt ?man}, {\tt ?man1}, \ldots\/, are automatically
variables of sort {\tt man}.  It is illegal to define certain symbols,
such as {\tt u}, \ldots\/, {\tt z}, {\tt ?u}, \ldots\/, or {\tt ?z},
perhaps followed by any number of digits, as sorted variables; by
convention, these are reserved to be unsorted.

The syntax of sorts can be described more exactly as follows:

A {\em sort symbol}
can be any \lisp\   symbol that
\begin{itemize}
\item is at least two characters long,
\item does not begin with the character ``{\tt ?},
\item is not the symbol {\tt NIL},
\item is not the (keyword) symbol {\tt :none}, and
\item is not a keyword symbol.
\footnote{Unless \snark\  option
{\tt allow-keyword-sort-symbols} is true.}
{\em TRUE} and {\em FALSE} are predefined as the topmost
bottommost sorts.
\end{itemize}


It is permissible to intermix sorted and unsorted symbols;  unsorted
terms are implicitly of sort {\tt true}, and every sort is a subsort
of {\tt true}.  Thus the unsorted version of \snark\  can be regarded
as a special case of the sorted version.

Once a sort structure has been declared, it becomes illegal to apply a
function or a predicate symbol to a term whose argument is of an
unsuitable sort.  Thus \snark\  will give an error if we say
\begin{verbatim}
  (parent the-maltese-falcon bob)
\end{verbatim}
because {\tt parent} takes arguments of sort {\tt person}, and {\tt
the-maltese-falcon} is not of sort {\tt person}.

Thus, the sort mechanism serves as a debugging aid.  In a sorted
theory, many errors in formulating assertions and queries show up as
sort errors, and are easily detected.  Without the sort mechanism,
some of these conceptual errors would only become evident when \snark\
failed to find a proof; when that happens, it is difficult to decide
which assertion contains the error that is the cause of the failure.

A more important effect of the sort structure is that it limits the
application of resolution and other inference rules.  \Snark\  will
never allow two terms to be unified if their sorts are incompatible.
For example, the variable {\tt ?person1} may be unified with a
constant {\tt carol} of sort {\tt woman}, because {\tt woman} is a
subsort of {\tt person}---we can always take {\tt ?person1} to stand
for a woman.  But a variable {\tt ?woman1} may not be unified with a
constant {\tt the-president} of sort {\tt person}, because we cannot
be certain that {\tt the-president} is a woman.

Two variables of different sorts can be unified if we have not
declared the sorts to be disjoint---the unified variable will have as
its sort the conjunction of the two original sorts.  A variable {\tt
?man1} cannot be unified with a variable {\tt ?woman2}, because we
have declared the sorts {\tt man} and {\tt woman} to be disjoint; no
one can be both a man and a woman.  But a variable {\tt ?person1} can
be unified with a variable {\tt ?man2} and vice versa; the unified
variable will be of sort {\tt man}.  \Snark\  will block application of
resolution, paramodulation, and other rules if they violate these
restrictions.

The sort mechanism gives us abbreviated ways of saying things about
subsets of our universe of discourse.  For example, we can
introduce an assertion
\begin{verbatim}
  (assert '(not (brother ?woman ?person))
   :name 'women-are-not-brothers)
\end{verbatim}
to mean that a women cannot be the brother of any person.  As we indicated
earlier, if we had no sort
mechanism, we would be forced to write this in terms of predicate symbols, as
\begin{verbatim}
  (assert
   '(implies
     (and (woman ?x) (person ?y))
     (not (brother ?x ?y)))
   :name 'women-are-not-brothers)
\end{verbatim}
The restrictions on unification makes \snark\  behave as if the
conditions \verb'(woman ?x)' and \verb'(person ?y)' were actually
there, when they are not.

Not only is the latter form of assertion more cumbersome to write, but
also it is less efficient for \snark\/.  The sort mechanism allows us
to make in one step an inference that would require several steps if
people and women were represented by predicate symbols.

Furthermore, the version of {\tt women-are-not-brothers} with sorts is
a unit assertion---it has no connectives.  Unit clauses have a
beneficial effect on the search space.  In particular, applying the
resolution rule to a unit and a formula yields a smaller formula;
applying the resolution rule to a nonunit and a formula may yield a
larger formula, and produce a correspondingly larger search space.

In declaring a sort structure, we are saying what expressions in the
language are meaningful, not what expressions are true.  For instance,
we did not declare the predicate symbol {\tt brother} with the sort
declaration
\begin{verbatim}
  (declare-predicate-symbol 'brother 2
    :sort '(boolean man person))
\end{verbatim}
Even though we expected that someone's brother will always be a man, we
did not want to exclude from the language formulas in which the first
argument of {\tt brother} is of sort {\tt woman}; otherwise, we would
have had no way of saying that the expression \verb|(brother betty bob)|
is false.  Merely being false is not the same as being meaningless.
We declared {\tt brother} on sorts for which the brother
relationship is meaningful.  If we had wanted to exclude such expressions
from the language, we could have chosen the latter declaration and insisted
that the first argument be a man.

Note that there is no way to include in an assertion the explicit
condition that something is of a particular sort, or that it is not of
a particular sort.  For instance, we cannot say something like
\begin{verbatim}
  (implies
   (brother ?person1 ?person2)
   ``?person1 is of sort man'')
\end{verbatim}
in the \snark\  language.
In choosing to represent gender as a sort, we have decided that we
will know in advance whether a person is male or female, and it won't
be necessary to deduce such things.

Note that is it permissible to use the same symbol to stand for a sort and a
predicate symbol; however, \snark\  will regard that as a coincidence; it will
not ensure that there is any relationship between the meanings of the two
symbols.  (\Kifsnark\/, the \kif\/-\okbc\ dialect of \snark\/, described
in Section
\ref{sec-kif-snark}, does enforce a relationship between sorts and predicate
symbols of the same name.)

\paragraph{Example: Grandmothers.}
\label{example-grandmothers}  In Section
\ref{subsec-basic-answer-extraction}, we showed how to find a
grandparent of Carol.  Suppose we would like to find a grandmother of
Carol, not just any grandparent.  Assume we have introduced sorts {\tt
man} and {\tt woman} and have declared the sorts for {\tt father} and
{\tt mother} accordingly, so that they yield people of sorts {\tt man}
and {\tt woman} respectively.  Then we may pose the query
\begin{verbatim}
  (prove '(grandparent ?woman carol) :answer '(ans ?woman))
\end{verbatim}
In other words, we are asking for a person of sort {\tt woman} who is
a grandparent of Carol.  We will then obtain an answer, either
\verb|(mother (father carol))| or \verb|(mother (mother carol))|,
depending on which proof is found first.  (In Section
\ref{subsec-multiple-answers}, we shall see how to obtain more than
one answer to such queries.)


%Incidentally, we will also obtain an endless stream of other answers,
%such as
%\begin{verbatim}
%  (mother (link (mother (mother carol)) carol))
%\end{verbatim}
%Here {\tt link} is the function mentioned in the definition of
% grandparent, as in Section
%\ref{subsec-conditional-answers}.  These additional answers correspond
%to new ways of describing the same two grandmothers, not additional
%grandmothers.

\subsection{Skolemization}
\label{subsec-skolemization}

If a formula contains explicit quantifiers, \snark\
will remove the quantifiers by skolemization.  In particular,
existentially quantified variables in assertions will be replaced by
functional terms, where the function is a newly introduced {\em skolem
function} or {\em skolem constant}.  We shall call the entire
functional term a {\em skolem term}.  Universal quantifiers will be
removed too, but their variables will remain variables. (Actually, whether a
quantifier is treated as universal or existential depends on whether it
appears within a negation in the assertion---see the remark on Quantifier
Force on Page {\pageref{subsec-quantifier-force}}).

For example, in Section \ref{subsec-language-and-theories} we introduced an
assertion, later called {\tt par}\-{\tt ent}-{\tt of}-{\tt parent}-{\tt
is}-{\tt grandparent}, that said that any parent of a parent is a
grandparent.  Suppose now we need to state the converse, that any grandparent
is the parent of a parent.  Then we may formulate this assertion in terms of
an explicit existential quantifier, as (in the sorted theory)
\begin{verbatim}
  (assert
   '(implies
     (grandparent ?person1 ?person2)
     (exists (?person)
             (and
              (parent ?person1 ?person)
              (parent ?person ?person2))))
   :name 'grandparent-is-parent-of-parent)
\end{verbatim}
Note that we cannot omit the existential quantifier, because
unquantified variables have tacit universal quantification.  If the
quantifier were missing, we would be saying that every grandparent is a
parent of every person, and that every person is in turn the parent of
the grandchild.

The new  assertion will be translated by \snark\  (if we turn off the
clausification option, Section \ref{clausification}) into
\begin{verbatim}
(Row grandparent-is-parent-of-parent
   (implies
    (grandparent ?person1 ?person2)
    (and (parent ?person1 (#:person-sk1 ?person1 ?person2))
         (parent (#:person-sk1 ?person1 ?person2) ?person2)))
   assertion)
\end{verbatim}
Here \verb'#:person-sk1' is the skolem function \snark\  introduced in
replacing the existential quantifier.  Intuitively speaking, if {\tt
?person1} is a grandparent of {\tt ?person2}, then
\begin{verbatim}
  (#:person-sk1 ?person1 ?person2)
\end{verbatim}
is the child of {\tt ?person1} who is a parent of {\tt ?person2}.
Skolem function symbols are prefixed by the sort of the variable whose
quantifier is being removed---in this case {\tt person}.  Note again
that \snark\  renames the variables in a row as it sees fit.

Note that, instead of using an explicit existential quantifier, we
could have phrased the assertion as follows:
\begin{verbatim}
  (assert
   '(implies
     (grandparent ?person1 ?person2)
     (and (parent ?person1 (link ?person1 ?person2))
          (parent (link ?person1 ?person2) ?person2)))
          :name 'grandparent-is-parent-of-parent)
\end{verbatim}
Here {\tt link} is our own name for the skolem function that \snark\
introduced automatically.  This formulation may be more mnemonic---the
link is the person who connects a grandparent and grandchild in the
family tree (either the grandchild's mother or father).  Also, we are
free to use the function {\tt link} in other assertions and queries,
if we so choose.

It is possible to provide \snark\  with a name to use when it
skolemizes a quantifier, using the keyword {\tt conc-name} in the
quantifier, as follows:
\begin{verbatim}
  (assert
   '(implies
     (grandparent ?person1 ?person2)
     (exists ((?person :conc-name link))
             (and
              (parent ?person1 ?person)
              (parent ?person ?person2))))
   :name 'grandparent-is-parent-of-parent)
\end{verbatim}
(Note that the double parentheses in the list of quantified variables
are required; otherwise, \snark\  will expect {\tt :conc-name} and {\tt
link} to be additional variables of the quantifier and report an
error.)  This formula will be skolemized (assuming clausification is
turned off) as
\begin{verbatim}
(Row grandparent-is-parent-of-parent
   (implies
    (grandparent ?person ?person1)
    (and
     (parent ?person (#:link1 ?person ?person1))
     (parent (#:link1 ?person ?person1) ?person1)))
   assertion)
\end{verbatim}
Here \snark\  has not used the exact name we have provided, but it has
 incorporated the string {\tt link} into the name
\verb'#:link1' it has constructed.
 This is because \snark\  needs to invent a unique symbol every time it
 constructs a skolem function.
 If we gave the same conc-name {\tt link} to another quantifier as
 well, \snark\  would invent a different skolem function symbol for the new
 quantifier, but both symbols would incorporate the string {\tt link}.

If an existential quantifier to be removed is within the scope of some
 universal quantifiers, the new skolem function will have arguments---the
 variables of those quantifiers.  (We include the invisible quantifiers that
 bind the free variables of the assertion.)  Otherwise, we introduce skolem
 constants, not skolem functions.  For example, if we introduce the assertion
\begin{verbatim}
  (assert
   '(exists (?person) (parent betty ?person))
   :name 'betty-has-a-child)
\end{verbatim}
\snark\  will transform this into the assertion
\begin{verbatim}
(Row betty-has-a-child
   (parent betty #:person-sk9)
   assertion)
\end{verbatim}
Here \snark\  has made up its own name, the skolem constant
 \verb|#:person-sk9|, for Betty's child.

%%The answer generated for this version of the query is
%%\begin{verbatim}
%%  (answer-if
%%   (red-headed (#:sk1 #:sk3 #:sk2))
%%   (parent (#:sk1 #:sk3 #:sk2) #:sk2)
%%   (parent #:sk3 (#:sk1 #:sk3 #:sk2))))
%%\end{verbatim}
%%Here \verb|(#:sk1 #:sk3 #:sk2)| is \snark\/'s name for the person we
%%earlier described as \verb'(link alice carol)'

\paragraph{Remark: Quantifier Force.}
\label{subsec-quantifier-force}
If an existential quantifier is within the scope of a single negation, it
will behave as a universal quantifier and will be treated accordingly.  In
particular, during skolemization, its variables will remain as variables.
This happens even if the negation is only implicit, when the quantifier is in
a query or in the antecedent of an implication, say.  A quantifier that
behaves as a universal, even if it is syntactically an existential, is said
to have {\em universal force}.

Similarly, it can happen that a universal quantifier will have {\em
existential force} if it is within the scope of a single explicit or
implicit negation---in this case, its variable will be replaced by a
skolem term during skolemization.

Thus, the way quantifiers are treated in queries is precisely the
reverse of the way they are treated in assertions---universally
quantified variables are replaced by skolem terms, while existentially
quantified variables remain variables when quantifiers are removed.
Additional negations reverse the force of the quantifiers yet again;  thus,
an existential quantifier that is within the scope of precisely two explicit
or implicit negations does have existential force.

The skolemization procedure is justified by showing that a set of rows
is contradictory precisely when the skolemized version of those rows
is contradictory.
\subsection{Equivalence}
\label{subsec-equivalence}
We could have combined the two assertions that
defined the notion of a grandparent into a single \snark\  assertion using
equivalence, as follows:
\begin{verbatim}
  (assert '(iff
            (grandparent ?person1 ?person2)
            (exists (?person)
                    (and (parent ?person1 ?person)
                         (parent ?person ?person2))))
          :name 'grandparent-iff-parent-of-parent)
\end{verbatim}
\Snark\  will break this down into two implications; if clausification
has not been turned off, these will then be transformed into clauses.


\paragraph{Exercise: In-Laws.}
\label{exer-in-laws}
In a sorted theory of families, introduce predicate symbols for the
relationships {\tt sib}\-{\tt lings}, {\tt sister}, {\tt brother}, {\tt
spouse}, {\tt wife}, {\tt husband}, {\tt sister-in-law}, and {\tt
brother-in-law}.  Introduce assertions that relate these notions to each
other.  Prove that if a man is a woman's brother-in-law, she is his
sister-in-law.  (In other words, the {\tt brother-in-law} and {\tt
sister-in-law} relations are {\em inverses}.)
\subparagraph{Hints.}  A man is a brother-in-law to another person if
he is husband to a sibling of that person, or if he is brother to a
spouse of that person.  Similarly for sister-in-law.

You may introduce assertions to express the following facts:
\begin{itemize}

\item[] A husband is a spouse; a wife is a spouse.

\item[] A male spouse is a husband; a female spouse is a wife.

\item[] A brother is a sibling; a sister is a sibling.

\item[] A male sibling is a brother; a female sibling is a sister.

\end{itemize}

\subparagraph{Solution.} The brother-in-law relation is defined by the
assertion
\begin{verbatim}
  (assert
   '(iff
     (brother-in-law ?person1 ?person2)
     (or
      (exists (?person)
              (and (husband ?person1 ?person)
                   (sibling ?person ?person2)))
      (exists (?person)
              (and (brother ?person1 ?person)
                   (spouse ?person ?person2)))))
   :name 'brother-in-law)
\end{verbatim}
The definition of {\tt sister}-{\tt in}-{\tt law} is analogous.
%%These
%%may be rewrite rules instead of simple assertions.
%%The relation {\tt
%%spouse} is declared to be commutative (as is {\tt sib}\-{\tt lings}).

The problem is stated as follows:
\begin{verbatim}
  (prove
   '(forall (?man ?woman)
         (implies
          (brother-in-law ?man ?woman)
          (sister-in-law ?woman ?man)))
   :name 'brother-and-sister-in-law-are-inverses)
\end{verbatim}
Note that we cannot omit the universal quantifier {\tt (forall (?man
?woman) ...)}  here, because then the query would be treated as if it were
surrounded by an invisible existential quantifier
\verb'(exists (?man ?woman)...)', which would change its meaning.


The fact that all husbands are spouses is expressed by the assertion
\begin{verbatim}
  (assert
   '(implies (husband ?person1 ?person2)
             (spouse ?person1 ?person2))
   :name 'husbands-are-spouses)
\end{verbatim}

The fact that male spouses are husbands is expressed by the assertion
\begin{verbatim}
  (assert
   '(iff (spouse ?man ?person)
         (husband ?man ?person))
   :name 'male-spouses-are-husbands)
\end{verbatim}
%%This may also be a rewrite rule.
Similar assertions apply to wives, and to
brothers, sisters, and siblings.  There are other assertions that
could be made (e.\  g., the definition of {\tt sibling}), but they are
not necessary to solve this problem.

%%If we don't wish to use rewrite rules, performance will be improved if
%%we select the ordering restriction, with an ordering such as the
%%following:
%%\begin{verbatim}
%%  (declare-ordering-greaterp
%%   'brother-in-law 'sister-in-law 'spouse 'husband 'wife)
%%  (declare-ordering-greaterp
%%   'brother-in-law 'sister-in-law 'sibling 'brother 'sister)
%%\end{verbatim}
%%These orderings follow the way in which the concepts are defined;
%%e.\  g., {\tt brother-in-law} is defined in terms of {\tt spouse}, {\tt
%%husband}, {\tt brother}, and {\tt sibling}.  In our experiments, use
%%of the ordering restriction reduced running time by about 75\%.  Using
%%rewrite rules instead of assertions reduced running time even more.

\subsection{Equality and Paramodulation}
\label{subsec-equality-and-paramodulation}

The equality relation \verb'(= ?x ?y)' means that \varx\  and \vary\
stand for the same thing.

Although it is possible to describe the equality relation by giving
its axioms as \snark\  assertions, if we want to reason about the
relation it is usually best to include the paramodulation rule among
our rules of inference.   The rule allows us to replace equals with
equals.  In its simplest form, the rule can be applied to two clauses
of form
\begin{verbatim}
  (or P[s])
\end{verbatim}
and
\begin{verbatim}
  (or (= s t) Q)
\end{verbatim}
where {\tt s} and {\tt t} are terms and the clause \verb'(or P[s])'
 contains at least one occurrence of {\tt s}.  Then the paramodulation
 rule will deduce the corresponding clause of form
\begin{verbatim}
  (or P[t] Q)
\end{verbatim}
where the literals \verb'P[t]' are obtained from the literals
  \verb'P[s]' by replacing all occurrences of {\tt s} with {\tt t}.
  The roles of {\tt s} and {\tt t} may be reversed, so that the rule
  is applied right to left to replace occurrences of {\tt t} with
  {\tt s}.  As with the resolution rule, the order of literals is not
  meaningful, and the replaced terms need not be identical to {\tt s}
  or {\tt t}, but merely unifiable.

We can include paramodulation in our arsenal by selecting the option
{\tt use-paramodulation}.
Then no axioms for equality need be provided by the user.

Let us look at an example of the application of the paramodulation
rule.

%%Also, whenever we want to do equality
%%reasoning, we must include among our assertions the reflexivity axiom
%%for equality,
%%\begin{verbatim}
%%  (assert '(= ?x ?x) :name 'reflexivity-of-equality).
%%\end{verbatim}
%%While other axioms for equality (such as transitivity and symmetry)
%%are implied by the paramodulation rule, the reflexivity property is
%%not, and so must be stated explicitly.
%%Here the variable \varx\  is
%%unsorted; this means that the reflexivity axiom will be applied to
%%terms of any sort.

\paragraph{Example: Grandchildren of Alice.}
\label{example-grandchildren-of-alice}
Suppose we wish to tell \snark\  that Carol's mother is
Betty and Betty's mother is Alice; then we may add the new assertions
\begin{verbatim}
  (assert '(= (mother carol) betty))

  (assert '(= (mother betty) alice))
\end{verbatim}
We assume that we have previously declared {\tt alice}, {\tt betty},
and {\tt carol} to be constants of sort {\tt woman}, and {\tt mother}
to be a function that takes a {\tt person} into a {\tt woman}.

If we then want to ask who is a grandchild of Alice, we may invoke
\snark\  with the query
\begin{verbatim}
  (prove '(grandparent alice ?person) :answer '(ans ?person))
\end{verbatim}

If paramodulation has been selected, \snark\  will complete the proof
with the answer {\tt carol}.  Here is the entire refutation:
\begin{verbatim}
(Refutation
(Row mother-is-parent
   (parent (mother ?person) ?person)
   assertion)
(Row mother-of-carol-is-betty
   (= (mother carol) betty)
   assertion)
(Row mother-of-betty-is-alice
   (= (mother betty) alice)
   assertion)
(Row who-is-the-grandchild-of-alice?
   (not (grandparent alice ?person))
   ~conclusion
   Answer (ans ?person))
(Row grandparent-iff-parent-of-parent-39
   (or (not (parent ?person ?person1))
       (not (parent ?person1 ?person2))
       (grandparent ?person ?person2))
   assertion)
(Row 42
   (parent betty carol)
   (paramodulate mother-is-parent mother-of-carol-is-betty))
(Row 43
   (parent alice betty)
   (paramodulate mother-is-parent mother-of-betty-is-alice))
(Row 90
   (or (not (parent alice ?person))
       (not (parent ?person ?person1)))
   (resolve who-is-the-grandchild-of-alice?
	    grandparent-iff-parent-of-parent-39)
   Answer (ans ?person1))
(Row 277
   false
   (rewrite (resolve 90 42) 43)
   Answer (ans carol))
)
\end{verbatim}
The derivations of Rows 42 and 43 illustrate the use of
paramodulation.  For instance, Row 42 has been obtained by applying
paramodulation to the assertion that a mother is a parent,
\begin{verbatim}
  (parent (mother ?person) ?person)
\end{verbatim}
and the assertion that the mother of Carol is Betty,
\begin{verbatim}
  (= (mother carol) betty)
\end{verbatim}
The variable {\tt ?person} has been unified with {\tt carol}.

The final step, which actually combines two
resolution steps, will be explained in a later discussion on rewrite
rules (Section \ref{subsubsec-rewrite-automatic}).

%%\typeout{move parents of carol}
%%Now, suppose we wish to tell \snark\  that Carol's and her father is Bob; then we may add the new assertion
%%\begin{verbatim}
%%  (assert '(= (father carol) bob))
%%\end{verbatim}
%%This is in addition to the assertion we introduced in the previous
%%example, that Carol's mother is Betty, that is
%%\begin{verbatim}
%%  (assert '(= (mother carol) betty))
%%\end{verbatim}

%%If we then want to ask who
%%Carol's parents are, we may invoke
%%\begin{verbatim}
%%  (prove '(parent ?person carol) :answer '(ans ?person))
%%\end{verbatim}


%%With this and subsequent invocations (via {\tt closure}) we get four
%%answers: \verb|(father carol)|, \verb|(mother carol)|, \verb|bob|,
%%and \verb|betty|.  Equality reasoning, via the paramodulation rule,
%%was necessary to obtain the last two answers.  \Snark\  can deduce that
%%Carol's father and mother are parents without using paramodulation.
%%Then, since it knows that Bob is Carol's father and Betty is Carol's
%%mother, it can use equality reasoning to conclude that Bob and Betty
%%are parents of Carol.

%%Repeated invocations of \snark\  will not always get all
%%possible answers to a given query; this depends on how its options
%%have been set. Furthermore, while using
%%subsumption by {\tt false} guarantees that we get syntactically
%%distinct answers to a query each time, it does not provide for us to
%%get semantically distinct answers.  In the above query, we obtained
%%\verb|(father carol)| on one invocation and {\tt bob} on another, even
%%though these are the same person.  The subsumption mechanism will not
%%discard either answer, because neither is a syntactic instance of the
%%other.



\section{Answer Management}
\label{sec-answer-extraction}
We have seen (in Section \ref{subsec-basic-answer-extraction}) how
answers to queries may be extracted from proofs.  In this section, we
consider some of the nuances of answer extraction---how to obtain
multiple answers and conditional answers, and how to restrict \snark\
to avoid unwanted answers.

\subsection{Multiple Answers}
\label{subsec-multiple-answers}
In Section \ref{subsec-basic-answer-extraction} we saw how to use
\snark\  to answer the query ``Who is Carol's grandfather?'' obtaining
a single answer, such as
\begin{verbatim}
  (father (father carol))
\end{verbatim}
Of course, Carol has more than one grandparent.  To find the others,
we may reinvoke \snark\  to find a different proof.  For this purpose,
we execute the function
\begin{verbatim}
  (closure)
\end{verbatim}
This is the function that computes computes logical consequences of
the current set of rows, stopping when \snark\  finds a new proof.  In
calling {\tt prove}, we have implicitly been invoking {\tt closure} on
the initial set of rows.  If we call {\tt closure} after a proof has
been interrupted, it will pick up where it left off and try to complete
the proof, as we mentioned in Section \ref{subsec-invoking-snark}.
But if we call {\tt closure} after a proof has been completed, \snark\
will try to find a different proof.


Since the example was introduced in the unsorted version of the family
theory, we continue in that version here.  \Snark\  finds a second
proof, which differs from the first only at the last step:
\begin{verbatim}
(Refutation
 ...
(Row mother-is-parent
   (parent (mother ?x) ?x)
   assertion)
 ...
(Row 23
   (not (parent ?x carol))
   (resolve 12 father-is-parent)
   Answer (ans (father ?x)))
(Row 31
   false
   (resolve 23 mother-is-parent)
   Answer (ans (father (mother carol))))
)
\end{verbatim}
In the last step, we have used the assertion that a mother is a
parent---in the first proof, we used the assertion that a father is a
parent instead.

This new proof gives us a different answer: the father of the mother
of Carol.  Repeated invocation of \snark\  via {\tt closure} gives
another two answers: \verb|(mother (father carol))| and
\verb|(mother (mother carol))|.  We have thus found four grandparents
for Carol.

There is no guarantee, however, that a different proof will yield a
different answer.  If we reinvoke \snark\  once more, we find yet
another proof, but the answer, \verb|(father (father carol))|, is the
same as the first one we discovered.  Reinvoking \snark\  again yields
more duplicate answers.

\subsection{Avoiding Duplicate Answers}
\label{subsec-avoiding-duplicate-answers}
\label{subsec-subsumption}

If we want to avoid this sort of duplication, we may rely on
\snark\/'s subsumption mechanism.  Subsumption is a strategic control
mechanism which avoids duplication of effort.  If the subsumption
strategy is in operation (and it is the default) and two formulas are
derived such that one is logically more general than the other, the
less general formula is discarded.  In the clausal case, this happens
when the subsumed clause contains an instance of the subsuming clause
among its disjuncts.

For example, if we have derived the two clauses
\begin{verbatim}
  (parent ?x carol)
\end{verbatim}
and
\begin{verbatim}
  (or (parent (father ?y) carol)
      (grandparent ?w ?z))
\end{verbatim}
the latter (``subsumed'') clause will be discarded; only the former
clause will be retained.  This is because one of the disjuncts of the
latter clause, \verb|(parent (father ?y) carol)| is an instance of the
former; any proof that uses the latter clause will correspond directly
to a proof that uses the former, so there is no need to retain both.

If one clause subsumes another and both have answer formulas, we cannot
discard the subsumed clause without risking loss of answers; a proof
using the subsumed clause may yield a different answer from a proof
using the subsuming clause.
For example, if we pay no attention to answers, a row
\begin{verbatim}
(Row 12
   (or (not (parent ?x ?y)) (not (parent ?y carol)))
   . . .
   Answer (ans ?x))
\end{verbatim}
is subsumed (as \snark\  observes) by the row
\begin{verbatim}
(Row 23
   (not (parent ?x carol))
   (resolve 12 father-is-parent)
   Answer (ans (father ?x)))
; Subsumed 12
\end{verbatim}
However, if we discard Row 12, we may be losing proofs which yield
answers other than \verb'(father ?x)';  Row 23 may be more general but
its answer is not.

If we want to get multiple answers for our query, we must be sure that
the option {\tt use-answers-during-subsumption} is selected; in fact,
this is the default.  In this case, the subsumed clause will be
discarded only if its answer is also a special case of the answer
associated with the subsuming clause.  In the preceding example, if
answers are used during subsumption, Row 23 will not be regarded as
subsuming Row 12.

 \Snark\  does not normally do subsumption on the final formula {\tt
false}; this formula would subsume all the formulas derived previously
or subsequently.  However, if we are interested in extracting multiple
answers from proofs without duplicating answers, we must select the
option {\tt use}-{\tt subsumption}-{\tt by}-{\tt false}; this option
is not selected by default.  Then the final {\tt false} formula of the
first proof will subsume all derived rows whose answer formula is
an instance of (or identical to) the answer already found; formulas
with different answers will be retained.

If we select the option {\tt use-subsumption-by-false} for
the problem of finding Carol's grandparents, the final row of the
first proof,
\begin{verbatim}
(Row 30
   false
   ...
   Answer (ans (father (father carol))))
\end{verbatim}
will subsume any row with the answer \verb'(father (father carol))'.
All these rows will be discarded.  However, rows that contain
distinct answers, such as \verb'?x', \verb'(father ?x)', and
\verb'(father (mother ?x))', will be retained.
If we invoke \snark\  four
times, we get the four different grandparents of Carol, as before.
If we have not introduced any assertions other than the ones presented in
Section \ref{subsec-basic-answer-extraction}, we exhaust the agenda
with the fifth invocation of \snark\/.  All the duplicate answers have
been subsumed.

On the other hand, if we have introduced the assertion
\begin{verbatim}
  (assert
   '(implies
     (grandparent ?x ?z)
     (and (parent ?x (link ?x ?z))
          (parent (link ?x ?z) ?z)))
          :name 'grandparent-is-parent-of-parent)
\end{verbatim}
as in Section \ref{subsec-skolemization},
we will obtain an endless stream of additional answers, such as
\begin{verbatim}
  (father (link (father (father carol)) carol))
\end{verbatim}
This is another way of describing Carol's paternal grandfather,
\begin{verbatim}
  (father (father carol))
\end{verbatim}
It is not a new answer, just a different representation for one of the
answers we have seen previously.  We shall call this sort of
repetition of answers {\em semantic} duplication, to distinguish it
from {\em  syntactic} duplication, in which literally the same answer
appears more than once.

Of course, we could simply remove the assertion {\tt grand}\-{\tt
parent}-{\tt is}-{\tt par}\-{\tt ent}-{\tt of}-{\tt parent}, but it
may be necessary for some other proofs.  In Section
\ref{subsec-constructive-answer-restriction}, which follows, we shall
see a mechanism for avoiding this sort of duplication.

\subsection{Constructive Answer Restriction}
\label{subsec-constructive-answer-restriction}
There is no way of eliminating semantic duplication of answers
altogether, but \Snark\/'s ``constructive-answer restriction''
mechanism is one way of reducing semantic duplication.  More
important, it ensures that answers are provided in terms of a useful
vocabulary.  Let us see how this mechanism operates.

Suppose, in the theory we have been developing, we have provided the
assertion that Carol's mother is Betty, i.\  e.,
\begin{verbatim}
  (assert '(= (mother carol) betty))
\end{verbatim}
If we want to ask who is
Carol's mother, our query is then
\begin{verbatim}
  (prove '(= ?person (mother carol)) :answer '(ans ?person))
\end{verbatim}
As it stands now, we will get two answers, {\tt betty} and
\verb'(mother carol)'.  The second answer is correct but unhelpful---if
we ask ``Who is the mother of Carol?'', we are not happy to be told
``the mother of Carol,'' even though the mother of Carol is certainly
the mother of Carol.  One way to avoid such unhelpful answers is to
indicate that the answer must be expressed without mentioning the
function symbol {\tt mother}.  To do this, we select the option {\tt
use-}{\tt constructive-}{\tt answer-}{\tt restriction} (as in Section
\ref{subsec-select-option}) and, after
initialization but before beginning the proof, we make the declaration
\begin{verbatim}
  (declare-function-symbol 'mother 1 :allowed-in-answer nil)
\end{verbatim}

This means that we will reject all rows that contain the function
symbol {\tt mother} in the answer formula.  If we like, we can combine
this declaration with the sort declaration:
\begin{verbatim}
  (declare-function-symbol 'mother 1 :sort '(woman person)
			   :allowed-in-answer nil)
\end{verbatim}

If we ask who is the mother of Carol with the above declarations, we
get only the single answer {\tt betty}.  The proof-steps that lead to
the answer \verb'(mother carol)' are rejected because their answer
contain the forbidden symbol {\tt mother}.

The example in Section \ref{subsec-avoiding-duplicate-answers} affords
another example of the use of the constructive answer restriction to
avoid semantically duplicated answers.  In finding the grandparents of
Carol, we obtain an endless stream of answers, such as
\begin{verbatim}
  (father (link (father (father carol)) carol))
\end{verbatim}
in terms of the function {\tt link}.  If we use the constructive
answer restriction and prohibit the function symbol {\tt link} to
appear in an answer, we obtain only the four distinct grandparents of
Carol.

Constants and predicate symbols may also be declared to be disallowed
in the answer, although the reason for disallowing a predicate symbol
in the answer will not become apparent until we discuss conditional
answers (Section \ref{subsec-conditional-answers}).  If a symbol has
no declaration, the default is that it is permitted in the answer.

Whether a symbol is allowed in the answer or not is a
context-dependent decision.  If we were to ask who a person's
grandparents are, we might be perfectly happy to learn that their
mother's mother is one of them; in that case, we would not declare
that the symbol {\tt mother} is not allowed in the answer.

\paragraph{Exercise: Riddle.}
\label{exer-riddle}
There is an old riddle
\begin{verse}
Brothers and sisters have I none,\\
But this man's father is my father's son.

Who am I?
\end{verse}
Using the vocabulary we have already introduced, formulate this as a
\snark\  problem, add any missing knowledge about family relations as
assertions, and use \snark\  to solve the riddle.

\subparagraph{Hint.}
Define two people to be siblings if they are distinct and have at
least one parent in common.

Phrase ``Brothers and sisters have I none'' as an
assertion ``I have no siblings.''  (Declare {\tt i} to be a constant
that is not allowed in the answer.)

Phrase ``This man's father is my father's son'' as an assertion ``My
father is a parent of this man's.''  (Declare {\tt this-man} to be a
constant symbol of sort {\tt man}.)

Express as an assertion the fact that ``The male parent is the
father.''

Phrase ``Who am I?'' as the conclusion to be proved, ``I am equal to
?person1'', where ?person1 is the answer.

\subparagraph{Solution.}
Here are the declarations of {\tt i} and {\tt this-man}:
\begin{verbatim}
  (declare-constant-symbol 'i
                           :allowed-in-answer nil
                           :sort 'person)
  (declare-constant-symbol 'this-man :sort 'man)
\end{verbatim}
The first verse ``Brothers and sisters have I
none'' is expressed by the assertion
\begin{verbatim}
  (assert '(not (sibling i ?person))
          :name 'brothers-and-sisters-have-i-none)
\end{verbatim}
The second verse, ``This man's father is my father's son'' is
expressed by the assertion
\begin{verbatim}
  (assert '(parent (father i) (father this-man))
          :name 'this-mans-father-is-my-fathers-son)
\end{verbatim}
The fact that a male parent is the father is expressed by the
assertion
\begin{verbatim}
  (assert
   '(iff
     (parent ?man ?person)
     (= ?man (father ?person)))
   :name 'male-parent-is-father)
\end{verbatim}
The definition of sibling is given by
\begin{verbatim}
  (assert
   '(iff
     (sibling ?person1 ?person2)
     (and
      (not (= ?person1 ?person2))
      (exists (?person)
           (and
            (parent ?person ?person1)
            (parent ?person ?person2)))))
   :name 'siblings-share-a-parent)
\end{verbatim}
Note that is is necessary to state explicitly that siblings are
distinct; even though I have the same parents as myself, I am not my
own sibling.  Note also that the solution doesn't work if we insist
that siblings means full siblings---we must include half siblings.

The question is phrased as the conjecture
\begin{verbatim}
  (prove '(= i ?person1)
         :name 'who-am-i
         :answer '(ans ?person1))
\end{verbatim}
Note that if we hadn't declared {\tt i} to be disallowed in the
answer, we could have obtained {\tt i} as the answer---correct but not
helpful.

 \subparagraph{Remark: Skolem functions in answers.}  In the preceding
   riddle exercise (Section \ref{exer-riddle}), suppose we had
   included the assertion {\tt grand}\-{\tt parent}-{\tt iff}-{\tt
   parent}-{\tt of}-{\tt parent}, with the explicit existential
   quantifier.  If we invoked \snark\  again, we could have obtained
   the additional answer
\begin{verbatim}
  (#:person-sk1 (father (father this-man)) this-man)
\end{verbatim}
In other words, I am the person who is the parent of this man and
the child of his grandfather.   Another answer we can obtain by a
further invocation of \snark\  is
\begin{verbatim}
  (#:person-sk1 (mother (father this-man)) this-man)
\end{verbatim}
Here \verb'#:person-sk1' is the skolem function that resulted when
\snark\  removed the existential quantifier from the assertion.
These answers are semantic duplicates---they are both equal to
\verb'(father this-man)'.

If we prefer that a particular skolem function not be
allowed in the answer, we may mark the variable of the
quantifier in the same way that we would mark a constant,
function, or predicate symbol.  For instance, if we replaced the
existential quantifier \verb|exists (?person)| of the assertion {\tt
grandparent-iff}-{\tt parent}-{\tt of-parent} with
\begin{verbatim}
  exists ((?person :allowed-in-answer nil))
\end{verbatim}
we would obtain only the first answer \verb|(father this-man)|, not
the other two, in answering the riddle. (Note again that the double
parentheses are required.)  On there other hand, there will be times
when we do want to have skolem functions in answers; see, for example
the problem of the red-headed grandmother, in the forthcoming Section
\ref{subsec-conditional-answers}.

\paragraph{Exercise: Cousins.}
\label{exer-cousins}
Introduce assertions that define notions of {\tt sib}\-{\tt lings} and
{\tt cous}\-{\tt ins}.  These should express the facts that siblings
have at least one parent in common, as in the riddle
exercise, Section \ref{exer-riddle}) and that cousins are children of
siblings.  (We consider only first cousins here.)
Use \snark\  to prove that cousins have a grandfather in common.
\subparagraph{Solution.}  The definition of {\tt sibling} is given by the
assertion
\begin{verbatim}
  (assert
   '(iff
     (sibling ?person1 ?person2)
     (and
      (not (= ?person1 ?person2))
      (exists (?person)
           (and
            (parent ?person ?person1)
            (parent ?person ?person2)))))
   :name 'siblings-share-a-parent)
\end{verbatim}
The definition of {\tt cousin} is given by the assertion
\begin{verbatim}
  (assert
   '(iff
     (cousin ?person1 ?person2)
     (exists (?person3 ?person4)
             (and
              (parent ?person3 ?person1)
              (parent ?person4 ?person2)
              (sibling ?person3 ?person4))))
   :name 'cousins-are-children-of-siblings)
\end{verbatim}
The conclusion to prove is
\begin{verbatim}
  (prove
   '(forall (?person1 ?person2)
         (implies
          (cousin ?person1 ?person2)
          (exists (?person)
                  (and
                   (grandparent ?person ?person1)
                   (grandparent ?person ?person2)))))
   :name 'cousins-share-a-grandparent)
\end{verbatim}

Note that we cannot omit the existential quantifier
\begin{verbatim}
  (exists (?person)...)
\end{verbatim}
because it is
within the scope of the universal quantifier
\begin{verbatim}
  (forall (?person1 ?person2)...)
\end{verbatim}
Omitting the explicit existential quantifier would create an invisible
existential quantifier that would surround the entire query---the
order of the quantifiers would be reversed and the meaning of the
query would be changed.  We would be trying to prove the existence of
a single person who is a common grandparent of all pairs of cousins,
but no such person exists.

\subsection{Existentially Quantified Variables in Answers}
\label{subsec-existentials-in-answers}
Normally the answer field contains question-mark variables that are
unquantified in the query.  Although these variables have tacit
existential quantification, they are not inside the scope of any
explicit quantifier.

Sometimes, however, we would like to have the variable of an explicit
existential quantifier in a query appear in an answer.  A special
mechanism is required to do this, because the answer formula is not
within the scope of the existential quantifier.

For instance, in the Cousins exercise (Section \ref{exer-cousins}),
suppose we would like to find the cousins' common grandparent, as well
as to prove that this person exists.  We might be tempted to phrase
the query like this:
\begin{verbatim}
  (prove
   '(forall (?person1 ?person2)
         (implies
          (cousin ?person1 ?person2)
          (exists (?person)
                  (and
                   (grandparent ?person ?person1)
                   (grandparent ?person ?person2)))))
   :name 'cousins-share-a-grandparent
   :answer '(ans ?person))
\end{verbatim}
However, because the variable {\tt person} in the answer is outside
the scope of the existential quantifier, it does not refer to the same
person.

To remedy this, we may mark the variable as {\tt global}, by writing
it as \verb'(?person :global t)'.  The query is then phrased as
\begin{verbatim}
  (prove
   '(forall (?person1 ?person2)
         (implies
          (cousin ?person1 ?person2)
          (exists ((?person :global t))
                  (and
                   (grandparent ?person ?person1)
                   (grandparent ?person ?person2)))))
   :name 'cousins-share-a-grandparent
   :answer '(ans ?person))
\end{verbatim}
This tells \snark\  that the variable {\tt ?person} refers to the same
thing throughout the row, whether it is inside or outside the scope of
the existential quantifier.

From this query, we obtain the answer
\begin{verbatim}
  (ans
   (#:common-parent1
    (#:a-parent2 #:person-sk8 #:person-sk9)
    (#:b-parent3 #:person-sk8 #:person-sk9)))
\end{verbatim}
Here we have used the {\tt :conc-name} feature to give names to the
skolem functions in the assertions.  Thus \verb'#:common-parent1' is the
common parent of two siblings; we have rephrased the assertion as
\begin{verbatim}
  (assert
   '(iff
     (sibling ?person1 ?person2)
     (and
      (not (= ?person1 ?person2))
      (exists ((?person :conc-name common-parent))
           (and
            (parent ?person ?person1)
            (parent ?person ?person2)))))
   :name 'siblings-share-a-parent)
\end{verbatim}
Similarly, \verb'#:a-parent2' and \verb'#:b-parent3' are the siblings
who are parents of two cousins, in the assertion {\tt cousins}-{\tt
share}-{\tt a}-{\tt grandparent}.  The skolem constants
\verb'#:person-sk8' and \verb'#:person-sk9' are the two given cousins.
\subsection{Conditional Answers}
\label{subsec-conditional-answers}

Sometimes it is not possible to find a single definite answer to a
query, but it can be shown that one of several entities will satisfy
the query, depending on contingencies.  In this case, \snark\  can
produce a conditional answer.  This is particularly useful if we are
using \snark\  to construct a program, because it allows for the
introduction of conditional expressions, or tests, into the program
being constructed.

For example\footnote{This is a reformulation of a blocks-world problem
of Robert C. Moore.}, in the theory of family relations, suppose we
are told that Alice is a grandparent of Carol, that Alice is
red-headed, but that Carol is not red-headed.  We would like to find a
pair {\tt ?person1} and {\tt ?person2} such that {\tt ?person1} is a
parent of {\tt ?person2}, where {\tt ?person1} is red-headed but {\tt
?person2} is not.

%%First, let us note that the assertions for family relations we have been
%%given do not suffice to solve this problem.  We have been told that
%%the parent of a parent is a grandparent, but we have not been given
%%the converse: that every grandparent is the parent of a parent.  This
%%might be expressed by the following assertion:
%%\begin{verbatim}
%%  (assert '(implies
%%            (grandparent ?x ?z)
%%            (and (parent ?x (link ?x ?z))
%%                 (parent (link ?x ?z) ?z)))
%%          :name 'grandparent-is-parent-of-parent)
%%\end{verbatim}
%%In other words, if \varx\  is a grandparent of \varz\, there is a child
%%of \varx\  who is a parent of \varz\/; we call this person
%% \verb|(link ?x ?z)|. Let us add this assertion to our theory. (In Section
%%\ref{subsec-skolemization}, we shall reexpress this assertion in terms of
%%an explicit existential quantifier.)

Recall that (in Section \ref{subsec-skolemization}) we introduced
an assertion that a grandparent is always the parent of a parent, or,
more precisely,
\begin{verbatim}
  (assert
   '(implies
     (grandparent ?person1 ?person2)
     (and (parent ?person1 (link ?person1 ?person2))
          (parent (link ?person1 ?person2) ?person2)))
   :name 'grandparent-is-parent-of-parent)
\end{verbatim}
This version of the assertion uses the explicit function {\tt link};
later we shall consider what happens if we use the version with the
existential quantifier.

The assertion tells us that if Alice is a grandparent of Carol, there
is a link between them, a child of Alice who is a parent of Carol.
The answer to our query then depends on whether this link is
red-headed or not.  If so, the link and Carol satisfy the query,
because the link is red-headed but Carol is not. Otherwise, Alice and
the link satisfy the query, because Alice is red-headed and the link
is not.  Thus, a conditional answer is called for.

To construct conditional answers, we must select the \snark\  option
{\tt use}-{\tt conditional}-{\tt answer}-{\tt creation} (See Section
\ref{subsec-select-option}); it is not the
default.   We introduce the assertions that specify the situation:
\begin{verbatim}
  (assert '(grandparent alice carol)
          :name 'alice-is-grandparent-of-carol)

  (assert '(red-headed alice)
          :name 'alice-is-red-headed)

  (assert '(not (red-headed carol))
          :name 'carol-is-not-red-headed)
\end{verbatim}
Then we pose the query:
\begin{verbatim}
  (prove '(and
           (parent ?person1 ?person2)
           (red-headed ?person1)
           (not (red-headed ?person2)))
         :name 'red-headed-parent
         :answer '(parent ?person1 ?person2))
\end{verbatim}
\Snark\  proves the conclusion and yields that answer
\begin{verbatim}
  (answer-if
   (red-headed (link alice carol))
   (parent (link alice carol) carol)
   (parent alice (link alice carol)))
\end{verbatim}
In other words, if the link between Alice and Carol is red-headed,
then the link and Carol are the desired pair; otherwise, Alice and the
link are the pair.  This agrees with our informal reasoning.

If we fail to invoke {\tt use}-{\tt con}\-{\tt di}\-{\tt tion}\-{\tt
al}-{\tt an}\-{\tt swer}-{\tt crea}\-{\tt tion}, \snark\  will not form
a conditional answer.  Instead it will form a disjunction of the
instances of the answer formula that satisfy the query, without
indicating which instance holds in which situation.  In this case, it
will produce the answer
\begin{verbatim}
 (or
  (parent (link alice carol) carol)
  (parent alice (link alice carol))))
\end{verbatim}
%%\paragraph{Remark: Skolem functions in answers, again.}
%%Suppose that, instead of using the assertion {\tt grandparent}-{\tt
%%is}-{\tt parent}-{\tt of}-{\tt parent}, which contains the {\tt link}
%%symbol, we use the assertion {\tt grandparent}-{\tt iff-}-{\tt parent}-{\tt
%%of}-{\tt parent}, which is expressed in terms of an existential
%%quantifier.  Then, if we allow skolem functions in answers, we would
%%obtain the answer
%%\begin{verbatim}
%%  (answer-if
%%   (red-headed (#:person-sk1 alice carol))
%%   (parent (#:person-sk1 alice carol) carol)
%%   (parent alice (#:person-sk1 alice carol))).
%%\end{verbatim}
%%Here \verb'#:person-sk1' is the skolem function obtained by removing
%%the existential quantifier in the assertion  {\tt grandparent}-{\tt iff}-{\tt
%%parent}-{\tt of}-{\tt parent}---it corresponds to the function {\tt
%%link} in the earlier formulation of the assertion.

\section{Efficiency Considerations}
\label{sec-efficiency-considerations}

In this section we discuss several mechanisms for improving \snark\/'s
performance, including associative and commutative unification
(Section \ref{subsec-commutative-and-associative}), the set-of-support
strategy (Section \ref{subsec-set-of-support}), the recursive-path and
predicate ordering strategies (Sections \ref{subsec-recursive-path}
and \ref{subsec-predicate-ordering}), and rewrite rules (Section
\ref{subsec-rewrite-rules}).


When appropriate options are selected, \Snark\  is a logically complete
theorem prover; in other words, if a conclusion follows from the
assertions, \snark\/, equipped with the appropriate inference rules,
will eventually find a proof.  However, as the length of the proof or
the number of assertions grows, the truth of the preceding sentence
relies more and more on the word ``eventually''.

\Snark\/'s strategic mechanisms allow us to tune its performance for a
particular subject domain or theory.  If used properly, they can have
a dramatic effect on the size of the search space and on the time
necessary to discover a proof.  Whereas none of them is necessary for
the examples in this guide, their use is essential if we are
dealing with a large theory or searching for a long or difficult
proof.  However, some care is required in the use of control
strategies.  Subtle misuse of rewrite rules, for example, can lead to
incompleteness or even infinite looping.  While the set-of-support and
the recursive-path ordering strategies retain completeness when used
separately, the two can cause loss of completeness when used together.
Any of them may be incompatible with hyperresoluton or the
constructive answer restriction.  While it may be justifiable to
sacrifice completeness for the sake of improved performance, the user
should be aware that if \snark\  fails to find a proof, the cause may
be unforeseen interactions with control strategies.  In such a case,
we can experiment with disengaging the strategies.

\subsection{Commutative and Associative Symbols}
\label{subsec-commutative-and-associative}
 \Snark\  has special-purpose unification algorithms that allow us to
reason about symbols with special properties, without introducing
assertions that express these properties.

For example, the {\tt sibling} relation we introduced in the riddle
exercise (Section \ref{exer-riddle}) is commutative: if Arthur and
Susan are siblings, then so are Susan and Arthur.  The order is
irrelevant.

We could express this property by an assertion
\begin{verbatim}
  (assert
   '(iff
     (sibling ?person1 ?person2)
     (sibling ?person2 ?person1))
   :name 'symmetry-of-sibling)
\end{verbatim}
(It would suffice to use {\tt implies} rather than {\tt iff} here.)  However,
that assertion would have many consequences; the resolution rule applies to
it and any formula that mentions the {\tt sibling} relation.  Most of these
consequences would be irrelevant to the problem at hand, and each of them
would have its own consequences in turn, and so on.  We could be swamped by
the proliferation of irrelevant clauses.

Instead we choose to declare that {\tt sibling} is a
commutative predicate, and drop the assertion.  For this purpose, we
include the declaration
\begin{verbatim}
  (declare-predicate-symbol 'sibling 2 :commutative t)
\end{verbatim}
anywhere after initialization and before use of the symbol.  This means that
the commutative unification algorithm will be used when we attempt to unify
two atoms with the predicate symbol {\tt sibling}.  Although commutative
unification is slower than ordinary unification, its employment here prevents
\snark\  from generating lots of unnecessary consequences.

We can declare function symbols as well as predicate symbols to be
commutative.  Function symbols can also be declared to be associative.
For associativity, we use the keyword {\tt :associative}.

If \snark\  sees an assertion that is an instance of associativity or
commutativity, it will remove the assertion automatically and instead
declare the appropriate symbol to be associative or commutative.
Thus, if we did chose to include the assertion {\tt symmetry-of-sibling}
as an assertion, \snark\  would simply remove the assertion and declare
the relation {\tt sibling} to be commutative.

\subsection{Set of Support}
\label{subsec-set-of-support}
The set-of-support strategy causes \snark\  to pay special attention to a
particular subset of the rows derived in searching for a proof.  Typically
this {\em set of support} includes the desired (negated) conclusion, and often
it includes special hypotheses required for that conclusion to hold, but it
may exclude all the other assertions.  In observing the strategy, we only
apply a rule of inference to a set of rows if at least one of the rows is
{\em supported}, i.\  e.,
belongs to the set of support.  The newly inferred row is then added to the
set of support.

If we have a large set of assertions and the set of support is
relatively small, applying the strategy may allow us to ignore most of
the assertions and help us focus our attention on inferences that are
related to the desired conclusion.

Selecting the set of support strategy is a bit different from the
selection of other \snark\  options.  The strategy is always turned
on---there is no way to turn it off---but initially every row is
included in the set of support, which means that the strategy has no
effect; no inferences are excluded.

To actually benefit from the strategy, we must indicate some rows to
be excluded.  Normally, we choose the
option
\begin{verbatim}
  (assert-supported nil)
\end{verbatim}
to exclude all the assertions from the set of support.  The option
must be selected before any assertions are made.   Inferences can
still be made from these assertions, but only if some member of the set
of support takes part in the inference step.  For instance, we can
apply the resolution rule to any assertion and a member of the set of
support, but not to two assertions.

The negation of the conclusion (obtained from the argument of the {\tt prove}
function) will normally be included in the set of support.  If there are
certain special assertions that we wish to include in the set of support,
even if assertions are generally excluded,
we can assert them by saying (for a formula \verb'<Form>')
\begin{verbatim}
  (assert <Form> :supported t)
\end{verbatim}
This will override the general policy that assertions are not to be
supported.

For instance, if we execute
\begin{verbatim}
  (assert
    (implies
     (and
      (parent ?person1 ?person2)
      (parent ?person2 ?person3))
     (grandparent ?person1 ?person3))
    :name 'parent-of-parent-is-grandparent
    :supported t)
\end{verbatim}
then this assertion will be supported.  We might do this because we believe
this assertion will be relevant to the proof, or class of proofs, we are
seeking.

If there are two unsupported
assertions,
\begin{verbatim}
  (parent alice betty)
\end{verbatim}
and
\begin{verbatim}
  (parent betty carol)
\end{verbatim}
we can still use resolution and the assertion {\tt parent}-{\tt of}-{\tt
parent}-{\tt is}-{\tt grand}\-{\tt parent} to deduce
\begin{verbatim}
  (grandparent alice carol)
\end{verbatim}
If none of these assertions were supported, the inference would be illegal.

Normally a formula that is deduced from a supported formula is also
supported; in other words, being supported is {\em inherited}.
For example, the formula
  \verb'(grandparent alice carol)'
we just deduced will be supported, even though the two facts it was deduced
from,
\verb'(parent alice betty)' and \verb'(parent betty carol),' are not.
We can
declare that a formula is to be supported but that its supportedness is not
to be inherited by tagging it with the keywords
\begin{verbatim}
  :supported :uninherited
\end{verbatim}
instead of
\begin{verbatim}
  :supported t
\end{verbatim}
If the assertion {\tt parent}-{\tt of}-{\tt parent}-{\tt is}-{\tt
grand}\-{\tt parent} were so tagged, the new deduced formula would not be
supported.


Another way to force a particular assertion {\tt <Form>} to belong to the set
of support is to execute
\begin{verbatim}
  (assume <Form>)
\end{verbatim}
in place of
\begin{verbatim}
  (assert <Form>)
\end{verbatim}
The construct {\tt assume} is synonymous with {\tt assert}, but when we
exclude assertions made via {\tt assert} from the set of support by saying
\begin{verbatim}
  (assert-supported nil)
\end{verbatim}
we have no effect on those assertions made via {\tt assume};  they will still
be supported.  Typically, these {\em assumptions}
are special hypotheses for the theorem being proved, and hence are
particularly likely to be relevant to the proof.

If we choose to, we can even exclude assertions made via {\tt assume} from the
set of support by saying
\begin{verbatim}
  (assume-supported nil)
\end{verbatim}
This is unusual because the point of having two synonymous constructs,
assertions and assumptions, is that we can support assumptions while
excluding ordinary assertions.  We can even exclude the negation of the
conclusion from the set of support by saying
\begin{verbatim}
  (prove-supported nil)
\end{verbatim}
The reason for doing this sort of thing is to explore the effect of different
search strategies on the same problem.

In some theorem provers and other rule-based systems, a distinction is made
between forward- and backward chaining rules.  Forward-chaining rules allow us
to reason forward from assertions; backward-chaining rules allow us to reason
backward from the desired conclusion.  The support mechanism in \snark\
allows us to mimic the behavior of forward and backward chaining.  When we
applied the assertion {\tt parent}-{\tt of}-{\tt parent}-{\tt is}-{\tt
grandparent} to two other assertions, we were using it as a forward-chaining
rule.  In general, forward-chaining behavior is obtained by supporting
assertions and assumptions;  backward-chaining behavior is obtained by
supporting the desired conclusion.



The set-of-support strategy is complete if the complement of the set of
support is satisfiable, that is, if the complement contains no contradictory
formulas.  For instance, if all of our assertions are consistent
(satisfiable), the strategy will be complete if only the desired
conclusion is supported.
Caution must be exerted in using the strategy, however, because it
is incompatible with other strategies, as mentioned in the introduction to
this section (Section \ref{sec-efficiency-considerations}).  The default in
\snark\  is that all assertions, assumptions, and desired conclusions are
supported---in other words, the set-of-support strategy does not impede any
inference.  This is a conservative choice---completeness will not be lost
because of incompatibilities between set-of-support and other strategies---but
for some problems it may not be the most efficacious decision.

The value of the set-of-support strategy is illustrated by the proof for the
riddle exercise of Section \ref{exer-riddle}, which puts 218 rows on the
agenda if the default settings are used, but only 50 rows if assertions are
excluded from the set of support and only the negation of the conclusion is
included; the time required is less than half.  Exact figures depend on how
many assertions are in the theory, of course.  The more irrelevant assertions
in the theory, the more important the strategy becomes.


\subsection{Recursive-Path Ordering Strategy}
\label{subsec-recursive-path}
 \Snark\  has a number of mechanisms by which we can impose an ordering
on the symbols in our vocabulary, which can give \snark\  a sense of
direction in searching for a proof.  These orderings say that certain
expressions are preferable to certain others, and will restrict the
action of \snark\/'s rules so that they will tend to remove the less
favored expressions.  We discuss two ordering strategies: the
recursive-path ordering strategy, which restricts application of the
paramodulation rule, and the predicate ordering strategy, which
restricts application of the resolution rule.  Both of these are
referred to as symbol-ordering strategies.

The recursive-path ordering strategy uses an ordering on the constant
and function symbols of our vocabulary.   It is invoked by
\begin{verbatim}
  (use-term-ordering :recursive-path)
\end{verbatim}
The format of this command is unusual because \snark\  also allows other such
``term-ordering'' strategies, which may be stipulated here instead.

As we have observed, the paramodulation rule can be applied in two
directions; if the equality is \verb'(= s t)', it can be used
left-to-right to replace {\tt s} with {\tt t} or right-to-left to
replace {\tt t} with {\tt s}.  If we do not select an ordering
strategy, \snark\  will attempt applying the rule in both directions,
with some redundancy.  If we employ the recursive-path ordering
strategy, \snark\  can often avoid one of these two directions and
hence reduce the branchiness of the search space.

The recursive-path ordering strategy compares {\tt s} and {\tt t}
according to an ordering before allowing a replacement.  If {\tt s} is
greater than {\tt t}, it will not allow us to replace {\tt t} with
{\tt s}; we will only be permitted to apply paramodulation in
left-to-right order.  If {\tt t} is greater than {\tt s}, we will only
be allowed to apply the rule right-to-left.  In either of these cases,
we say that the equality can be {\em ordered}.  Otherwise, if no order
exists between {\tt s} and {\tt t}, the strategy will allow us to
apply the rule in either direction.  For example, the recursive-path
ordering will not allow us to order a commutativity axiom, such as
\begin{verbatim}
  (= (f ?x ?y) (f ?y ?x))
\end{verbatim}

As we have seen (Section \ref{subsec-commutative-and-associative}),
\Snark\  deals with associativity and commutativity, in particular, by
invoking a special-purpose unification algorithm, but other equalities
may be unorderable as well.

To define the ordering on terms, we declare an ordering on the
constant and function symbols.  For instance, suppose we prefer that
when we have assertions such as
\begin{verbatim}
  (assert '(= (mother carol) betty))
\end{verbatim}
we always wish to replace the constant \verb'betty' with the term
 \verb'(mother carol)' so that we can use properties of the
 function \verb'mother'.  If so, we can declare the orderings
\begin{verbatim}
  (declare-ordering-greaterp 'betty 'mother)
  (declare-ordering-greaterp 'betty 'carol)
\end{verbatim}
With this declaration, the equality will be applied in the
right-to-left direction.

The precise definition of recursive-path ordering is
complicated---see, for example, \cite{recursive-path}---but to order a
ground (variable-less) equality it suffices that all the constant and
function symbols on one side precede all the constant and function
symbols on the other.

If (for ordering other equalities) we want to say that
\verb'carol' is also to be preferred to \verb'mother', we can do it in
a single declaration,
\begin{verbatim}
  (declare-ordering-greaterp 'betty 'carol 'mother)
\end{verbatim}
The ordering we
provide on symbols must be loop-free, and every symbol must previously be
declared---otherwise \snark\  will give an error message.  Also, the name must
be unambiguous.  If we have introduced a constant {\tt betty} and a function
symbol {\tt betty}, \snark\  will not know which one we mean and will give an
error message.  For this purpose, we should use the alias mechanism (Section
\ref{subsec-sorts}) to give the two {\tt betty}'s distinct aliases, e.\  g.,
{\tt betty-con} and {\tt betty-fun}.  The declaration can then refer
unambiguously to {\tt betty-con}.

\subsection{Predicate Ordering Strategy}
\label{subsec-predicate-ordering}

The predicate ordering strategy, which controls the resolution rule, uses an
ordering on the predicate symbols of our vocabulary and extends the ordering
on terms to apply to atomic formulas.  It is selected by {\tt use}-{\tt
literal}-{\tt ordering}-{\tt with}-{\tt resolution}.  (There is also a
version of the restriction that applies to the paramodulation rule.)

Let us give an example: consider the exercise (Section
\ref{exer-cousins}) in which we showed that cousins have a common
grandparent.  Let us see how to introduce an ordering on the predicate
symbols.

We use four predicate symbols here, {\tt parent}, {\tt sibling}, {\tt
cousin}, and {\tt grand}\-{\tt par}\-{\tt ent}.  Note that {\tt grandparent}
and {\tt sibling} are defined in terms of {\tt parent}, and {\tt cousin} is
defined in terms of {\tt sibling} and {\tt parent}.  Therefore, it makes
sense during a proof to paraphrase {\tt cousin} in terms of {\tt sibling} and
{\tt parent}.  Then {\tt grandparent} and {\tt sibling} can be paraphrased in
terms of {\tt parent}.


  For example, we include the declaration
\begin{verbatim}
  (declare-predicate-symbol 'parent 2)
\end{verbatim}
We can then include the ordering
\begin{verbatim}
  (declare-ordering-greaterp 'cousin 'sibling 'parent)
  (declare-ordering-greaterp 'grandparent 'parent)
\end{verbatim}
This means that we will favor inferences that replace {\tt cousin}
with {\tt sibling} or {\tt parent}, that replace {\tt sibling} with
{\tt parent}, or that replace {\tt grandparent} with {\tt parent}.  (We
do not say whether we prefer {\tt cousin} or {\tt sibling} to {\tt
grandparent}, since we have no opinion on that at this time.)

 In proving this result without a symbol ordering, \snark\  may
generate more than a thousand rows before discovering a proof.
Selecting this ordering will allow \snark\  to find the proof after
generating fewer than a hundred rows.  The time required was about
about a twentieth of the time without the ordering strategy.

In comparing two formulas which have the same predicate symbol, the
ordering restriction will use the recursive-path ordering to compare
the argument terms of the two predicate symbols.  It is possible to
control the order in which the arguments are compared, but we shall
not discuss this technicality here.

If we want to use an ordering strategy but want \snark\  to invent
an ordering for us, we can select the option {\tt
use-default-ordering}. \Snark\/'s ordering will agree with any
orderings we have chosen, but \snark\  will fill in its own ordering
when we have not made any decision.  For example, since we have not
decided whether we prefer {\tt sibling} or {\tt grandparent}, \snark\
will decide one way or another, according to its own criteria.  Even
if we do not indicate any ordering at all, we may get improved
performance if we use the ordering strategy and the default
ordering, because the search space will be narrower: fewer inferences
are legal at each step.

These ordering restrictions must be used with some care.  They are
logically complete in isolation, but they are not in general complete
when used in combination with other strategies, or even with the
constructive answer restriction.

\subsection{Obtaining Left-to-Right Behavior}

  \Snark\  inference rules can operate on any atom in a formula.
Logic-pro\-gram\-ming languages, such as \prolog\/, on the other hand, commonly
operate on a formula in left-to-right order.  This behavior can be mimicked
in \snark\  by tagging a formula to be {\em sequential}.  If a formula is
sequential, only its left-most atom is available to be operated on.

We can indicate that a formula is to be processed sequentially by a keyword
argument, as in
\begin{verbatim}
  (assert
    (implied-by
     (grandparent ?person1 ?person3)
     (and
      (parent ?person1 ?person2)
      (parent ?person2 ?person3)))
     :sequential t)
\end{verbatim}
This means that  to apply the resolution rule, say, to this
formula, we must unify the leftmost atom,
\begin{verbatim}
  (grandparent ?person1 ?person3)
\end{verbatim}
rather than either of the two subsequent atoms.  If we do succeed in deriving
a consequence from this formula, the derived formula is also sequential.  In
particular, the instance of the second atom
\begin{verbatim}
  (parent ?person1 ?person2)
\end{verbatim}
must be operated on before the instance of the third atom
\begin{verbatim}
  (parent ?person2 ?person3)
\end{verbatim}
can be.  If we do not want formulas derived from a sequential formula to be
inherited, we can tag it
\begin{verbatim}
  :sequential :uninherited
\end{verbatim}
instead of {\tt t}.

If the keyword {\tt :sequential} is not specified, whether a formula is to be
treated sequentially is determined by the current value of {\tt
assert-sequential}, {\tt assume-sequential}, or {\tt prove-sequential}.  For
instance, if we declare
\begin{verbatim}
  (assert-sequential t)
\end{verbatim}
all assertions will be sequential.
\Snark\/'s default value is {\tt nil} for
all these options.


To approximate the behavior of \prolog\/---backward chaining and left-to-right
solution of goals, we declare all
assertions to be sequential and unsupported and we specify
\begin{verbatim}
  (prove goal :supported t :sequential t)
\end{verbatim}
Because sequentiality is inherited, all the formulas we derive will then be
treated in left-to-right order, as in \prolog\/.

 Like the support restriction, the sequentiality restriction must be used
with care to preserve completeness; it is only complete in special cases.
When using sequentiality, the user is viewing the assertions as programs, to
be executed in order.  Predicate-ordering strategies provide a safer way of
indicating which atoms of a formula to operate on first.


\subsection{Rewrite Rules}
\label{subsec-rewrite-rules}
\Snark\  has a rewrite rule mechanism that allows us to treat certain
designated equalities or equivalences as rewrite rules.  This means
that whenever an occurrence of the left side of the rule appears in a
row (henceforth called the {\em target}), it will be replaced by the
corresponding instance of the right side of the rule, immediately and
automatically.

For example, in Section \ref{subsec-equivalence}, we used an
assertion to define the grandparent relation:
\begin{verbatim}
  (assert
   '(iff
     (grandparent ?person1 ?person2)
     (exists (?person)
             (and (parent ?person1 ?person)
                  (parent ?person ?person2))))
   :name 'grandparent-iff-parent-of-parent)
\end{verbatim}

If we chose to represent the same equivalence by a rewrite rule, we would
instead say
\begin{verbatim}
  (assert-rewrite
   '(iff
     (grandparent ?person1 ?person2)
     (exists (?person)
             (and (parent ?person1 ?person)
                  (parent ?person ?person2))))
          :name 'grandparent-iff-parent-of-parent)
\end{verbatim}

There are several differences between these two statements in the way
they are treated by \snark\/.  The rewrite rule will immediately
replace any subformula of form \verb'(grandparent ?person1 ?person2)',
in any \snark\  row, with a corresponding formula
\begin{verbatim}
  (and (parent ?person1 term) (parent term ?person2))
\end{verbatim}
where {\tt term} is either a variable {?person} or a skolem term,
depending on the force of the quantifier (see Section
\ref{subsec-quantifier-force}).
The assertions and proof will appear as if the {\tt grandparent}
symbol did not exist.

Phrasing the statement as an assertion, on the other hand, will not
interfere with \snark\/'s usual operation.  Formulas involving the
{\tt grandparent} relation will be placed on the agenda to be
processed in due course.  Resolution with the assertion that defines
the relation will not cause the symbol to be replaced---instead, new
rows will be created and added to the agenda.

The fact that rewrite rules cause a replacement instead of an addition
to the agenda means that they can drastically reduce the search
space.  In the problem of showing that cousins have a grandparent in
common (Section \ref{exer-cousins}), if we replace the assertions that
define grandparents, cousins and siblings with rewrite rules, we obtain
a proof in a quarter of the time, generating a third the number of
rows.

Another difference between a rewriting and an ordinary inference is
that \snark\  will only do one-way matching, not full unification, in
performing a rewriting.  It will instantiate variables in the left
side of the rule to force them to be identical to terms in the target
formula, but it will not instantiate variables in the target formula
to force them to be identical to terms in the rule.

For example, suppose we have an ordinary
assertion (not a rewrite rule)
\begin{verbatim}
  (assert '(= (mother carol) betty))
\end{verbatim}
If we also have in our theory the assertion
\begin{verbatim}
  (assert '(parent (mother ?person) ?person)
          :name 'mother-is-parent)
\end{verbatim}
Then we can apply paramodulation to the two assertions, instantiating
{\tt per}\-{\tt son} be {\tt carol}, to obtain
\begin{verbatim}
  (parent betty carol)
\end{verbatim}
The instantiation was discovered by the
unification algorithm, in unifying the left side of the equality, the term
\verb'(mother carol)', with the subterm \verb'(mother ?person)' of the target
assertion, {\tt mother}-{\tt is}-{\tt parent}.

Now suppose we rephrase the theory so that the fact that Carol's mother
is Betty is expressed instead by the rewrite rule
\begin{verbatim}
  (assert-rewrite '(= (mother carol) betty))
\end{verbatim}
Then we cannot apply the rewrite rule to the assertion {\tt
mother}-{\tt is}-{\tt parent}, because \snark\
will not instantiate the variable \varx\  in the assertion to create
an instance of the left side of the rule.

\subsubsection{Proceed with Caution}
\label{subsubsec-rewrite-caution}

Rewrite rules can replace one formula with another, rather than merely
adding a new row, because they do not instantiate variables in the
target formula; this means that no proof that requires a different
instantiation is being lost due to the replacement.  However, caution
must be exercised in using rewrite rules instead of assertions.  Poor
choice of a rewrite rule can lead to incompleteness---\snark\  may fail
to prove valid conclusions if a fact is represented as a rewrite rule
rather than as an assertion.

For example, in the theory in which the fact that Betty is Carol's
mother is represented by an assertion, \snark\  can answer the query
\begin{verbatim}
  (prove '(parent betty ?person) :answer '(ans ?person)
   :name 'who-is-bettys-child?)
\end{verbatim}
The negation of the conclusion directly contradicts the assertion
\begin{verbatim}
  (parent betty carol)
\end{verbatim}
which was obtained by the paramodulation step, giving the answer {\tt
carol}.

But if the fact that Betty is Carol's mother is represented by a
rewrite rule, we cannot deduce that Betty is a parent of Carol, and we
cannot answer the query.

Another caution on the use of rewrite rules is that it is the user's
responsibility to see that they terminate.  If we chose to represent the
symmetry of the sibling relation by a rewrite rule
\begin{verbatim}
  (assert-rewrite
   '(iff (sibling ?person1 ?person2)
         (sibling ?person2 ?person1))
   :name 'symmetry-of-sibling)
\end{verbatim}
we would have an infinite computation whenever we used the sibling
relation.

Finally, even if the use of a rewrite rule does not lead to
incompleteness or to an infinite loop, there is no guarantee that it
will speed up the search.  For instance, if a rewriting replaces a
simple atomic formula with a complex sentence, it may even make some
proofs more complex.


\subsubsection{Rewrite Rules May Be Introduced Automatically}
\label{subsubsec-rewrite-automatic}

\Snark\  will sometimes introduce rewrite rules automatically, to increase its
efficiency, when it observes a suitable opportunity.  If we select the option
{\tt use}-{\tt simplification}-{\tt by}-{\tt equalities}, \Snark\  will
introduce rewrite rules from asserted or deduced equalities.  For example, if
we are using the recursive-path ordering strategy and deduce an equality
that can be ordered by the strategy, \snark\  will introduce a rewrite rule
that will have the same effect.

 \Snark\/, in contrast with a human being, will never introduce rewrite rules
that lead to incompleteness or looping.  Therefore, rather than introducing a
rewrite by hand, it is usually preferable for a user to introduce an ordinary
assertion and to provide a symbol ordering that will cause \snark\  to
introduce the rewrite automatically, if it is safe.

Even if we have not selected special options, if we have a unit assertion
\verb'P', \snark\  will introduce a rewrite rule
\begin{verbatim}
  (assert-rewrite '(iff P true)).
\end{verbatim}
  Application of the rewrite rule will produce
some of the effects of the resolution rule; for instance, if we have a clause
\begin{verbatim}
  (or (not P') Q)
\end{verbatim}
where {\tt P'} is an instance of {\tt P}, applying the rule will (after
simplification) yield the clause \verb'Q'; this same clause would ultimately
have been obtained by resolution with the unit clause \verb'P', if the
rewrite rule had not been in place.  But the rewrite rule will be applied
immediately and automatically, when it becomes applicable as the result of
applying other rules.

This explains why we have seen \snark\  traces in which rewriting has been
applied, even when we have not introduced any rewrite rules.  For example,
the last step of the proof in the Grandchildren-of-Alice example, Section
\ref{example-grandchildren-of-alice}, is a resolution followed by a rewrite
that has the effect of a second resolution with a unit assertion---\snark\
has effectively combined two resolution steps into one.

In cases in which \snark\  invents a rewrite rule corresponding to an assertion, it will also
leave the assertion in place, so that other rules, such as paramodulation and
resolution, can be applied.

\paragraph{Exercise: Efficiency}
\label{exec-efficiency}
Experiment with the previous exercises to see if you can improve the
time required or the number of rows produced by using the
set-of-support strategy, symbol orderings, or rewrite rules.

\section{Temporal Reasoning}
\label{sec-temporal-reasoning}

Reasoning about time plays a central role in many knowledge-representation
applications.  \snark's temporal representation supports two kinds of
temporal entities, time points and time intervals, and relationships
between them, and is an extension of the temporal interval logic of Allen
\cite{allen}.  It also supports times of day and calendar dates. Many of the
relation names in \snark's temporal representation were adapted from Cyc's
upper ontology \cite{cyc-ul}.

A possible approach to reason with time is to provide the axioms for the
desired temporal inferences, and rely on \snark\/'s general-purpose inference
methods, such as resolution and paramodulation, to draw conclusions.  This
approach can involve a good deal of time-consuming search.  Alternatively,
one may use special-purpose inference methods for reasoning with temporal
knowledge.  A special-purpose reasoner can significantly improve
the speed of inference, but a suitable interface to the general-purpose
inference procedure must be designed.  \Snark\  supports a time and date
procedure with an interface to the ordinary resolution rule, based on the
{\em constraint resolution} framework \cite{burckert}.

The \snark\    temporal reasoning facility is switched on by selecting the
option \verb'use-temporal-reasoning', e.\  g., by evaluating
\begin{verbatim}
  (default-use-temporal-reasoning)
\end{verbatim}
before initialization; henceforth, in this section, we assume that the
facility has been turned on.  When using temporal reasoning, special meaning
is given to certain symbols, such as {\tt time-point}; it is possible for
the user to rename these symbols.

We begin with the relations that apply to time points; later we will consider
time intervals and relations between time points and intervals.

\subsection{Time Points}

A time point is a single moment of time; these are of sort
\verb'time-point'.  Terms of this sort can be treated like any other terms;
they may be arguments of predicate and function symbols, for example.  There
are some built-in operations that are already declared on time points.

There are three primitive relations between pairs of time points:
\begin{itemize}
 \item{\verb'(before ?time-point1 ?time-point2)':}

%BEGIN IMAGE
\begin{picture}(200, 30)(-30,0)
\put(0,0){\framebox(135,25)
{\put (10, 15){\circle*{4}{\scriptsize {\tt ?time-point1}}}
 \put (75, 5){\circle*{4}{\scriptsize {\tt ?time-point2}}}}}
\end{picture}
%END IMAGE
%HEVEA\imageflush
\newline \verb'?time-point1' is (strictly) earlier than
 \verb'?time-point2'.

(In general, we use the word {\em strict} to apply to relations that do not
allow time points to occur simultaneously.)  Here moving from left to right
corresponds to the passing of time.

 \item{\verb'(after ?time-point1 ?time-point2)':}

%BEGIN IMAGE
\begin{picture}(200, 30)(-30,0)
\put(0,0){\framebox(135,25)
 {\put (75, 15){\circle*{4}{\scriptsize {\tt ?time-point1}}}
  \put (10, 5){\circle*{4}{\scriptsize {\tt ?time-point2}}}}}
\end{picture}
%END IMAGE
%HEVEA\imageflush
\newline \verb'?time-point1' is
 later than \verb'?time-point2'.

\item{\verb'(simultaneous-with ?time-point1 ?time-point2)':}

%BEGIN IMAGE
\begin{picture}(200, 30)(-30,0)
\put(0,0){\framebox(135,25)
 {\put (40, 15){\circle*{4}{\scriptsize {\tt ?time-point1}}}
  \put (40, 5){\circle*{4}{\scriptsize {\tt ?time-point2}}}}}
\end{picture}
%END IMAGE
%HEVEA\imageflush
\newline \verb'?time-point1' is
 simultaneous with \verb'?time-point2'.
\end{itemize}
Note that these three relations are mutually exclusive and exhaustive: for
any two time points, precisely one of these is true.  Also note that the
relation \verb'simultaneous-with' is not the same as ordinary equality: one
could have two time points that occur simultaneously but are different in
other respects, e.g., one is the beginning of a new millennium and the other
is the end of the old one.  One of these time points could be regarded as
happy, the other as sad, so they are not equal.  Temporally, however, they
are treated as identical.  If one wants true equality, one should use instead
the relation \verb'=', which is stronger than
\verb'simultaneous-with' and has the same effect in temporal reasoning.

Given a set of temporal relations between time points, \snark\   will be able
to draw conclusions from them.  For example, suppose we are given four
time points such that
\begin{verbatim}
 (before time1 time2)
 (simultaneous-with time2 time3)
 (after time4 time3)
\end{verbatim}

This situation can be depicted as follows:
%BEGIN IMAGE
\begin{picture}(200, 50)(-10,0)
\put(0,0){\framebox(110,45)}
\put (10, 35){\circle*{4}{\scriptsize {\tt time1}}}
\put (40, 25){\circle*{4}{\scriptsize {\tt time2}}}
\put (40, 15){\circle*{4}{\scriptsize {\tt time3}}}
\put (75, 5){\circle*{4}{\scriptsize {\tt time4}}}
\end{picture}
%END IMAGE
%HEVEA\imageflush
\newline
Then the temporal reasoning component within \snark\   will be able to
conclude that
\begin{verbatim}
  (before time1 time4)
\end{verbatim}

 \Snark\  is complete and efficient for this kind of reasoning; in other
words, if a conclusion about time points follows from a set of facts asserted
using only the above three temporal relations, \snark\  will be able to deduce
the conclusion.

\subsection{Time Intervals}

  A time interval is a finite connected region of time.  Time intervals are
  of sort \verb'time-interval', which is disjoint from \verb'time-point';
  that is, no entity is both a time point and a time interval.


 A time interval has end-points, which are time points, and it also has
interior time points, which occur during the time interval. As in the Allen
logic, we do not identify a time interval with a set of time points.  The
Allen logic is even agnostic about whether the end-points are part of the
interval; that is not a meaningful question, because the original logic does
not mention time points.

Each time interval has a start-point and an end-point, which are time points.
Time intervals are always thought of as being nonempty, in the sense that
the start-point is always strictly earlier than the end-point.

\subsubsection{Allen Primitives}
\label{subsubsec-allen-primitives}

There are thirteen fundamental relations, known as the {\em Allen primitives},
between pairs of time intervals.  We say that the relation is {\em
strict} if it does not allow the start- or end-points to be identical.

\begin{itemize}
\item{\verb'(before ?time-interval1 ?time-interval2)':}

%BEGIN IMAGE
\begin{picture}(200, 42)(-30,0)
\put(0,0){\framebox(200,37)}
\put (10, 22){\fbox {\scriptsize{\tt ?time-interval1}}}
\put (120, 10){\fbox {\scriptsize{\tt ?time-interval2}}}
 \end{picture}
%END IMAGE
%HEVEA\imageflush
 \newline The end-point of \verb'?time-interval1' is
 (strictly) earlier than the start-point of \verb'?time-interval2'.

\item{\verb'(meets ?time-interval1 ?time-interval2)':}

%BEGIN IMAGE
\begin{picture}(240, 42)(-30,0)
\put(0,0){\framebox(200,37)}
\put (30, 22){\fbox {\scriptsize {\tt ?time-interval1}}}
\put (100, 10){\fbox {\scriptsize {\tt ?time-interval2}}}
 \end{picture}
%END IMAGE
%HEVEA\imageflush
 \newline The end-point of \verb'?time-interval1' is
 simultaneous with the start-point of \verb'?time-interval2'.

\item{\verb'(overlaps ?time-interval1 ?time-interval2)':}

%BEGIN IMAGE
\begin{picture}(240, 42)(-30,0)
\put(0,0){\framebox(200,37)}
\put (50, 22){\fbox {\scriptsize {\tt ?time-interval1}}}
\put (80, 10){\fbox {\scriptsize {\tt ?time-interval2}}}
 \end{picture}
%END IMAGE
%HEVEA\imageflush
 \newline The start-point of \verb'?time-interval1' is
 earlier than the start-point of \verb'?time-interval2', but
the end-point of \verb'?time-interval1' is
 (strictly) between the start- and end-points of \verb'?time-interval2'

\item{\verb'(starts ?time-interval1 ?time-interval2)':}

%BEGIN IMAGE
\begin{picture}(240, 42)(-30,0)
\put(0,0){\framebox(200,37)}
\put (60, 22){\fbox {\scriptsize {\tt ?time-interval1}}}
\put (60, 10){\framebox[3.2cm] {\scriptsize {\tt ?time-interval2}} }
 \end{picture}
%END IMAGE
%HEVEA\imageflush
 \newline The start-point of \verb'?time-interval1' is
 simultaneous with the start-point of \verb'?time-interval2', but
 the end-point of \verb'?time-interval1' is
  earlier than the end-point of \verb'?time-interval2.'


\item{\verb'(during ?time-interval1 ?time-interval2)':}

%BEGIN IMAGE
\begin{picture}(240, 42)(-30,0)
\put(0,0){\framebox(200,37)}
\put (65, 22){\fbox {\scriptsize {\tt ?time-interval1}}}
\put (55, 10){\framebox[3.2cm] {\scriptsize {\tt ?time-interval2}} }
 \end{picture}
%END IMAGE
%HEVEA\imageflush
 \newline The start-point of \verb'?time-interval1' is
 later than the start-point of \verb'?time-interval2', but
 the end-point of \verb'?time-interval1' is
  earlier than the end-point of \verb'?time-interval2.'


\item{\verb'(finishes ?time-interval1 ?time-interval2)':}

%BEGIN IMAGE
\begin{picture}(240, 42)(-30,0)
\put(0,0){\framebox(200,37)}
\put (75.5, 22){\fbox {\scriptsize {\tt ?time-interval1}}}
\put (55, 10){\framebox[3.2cm] {\scriptsize {\tt ?time-interval2}} }
 \end{picture}
%END IMAGE
%HEVEA\imageflush
 \newline The end-point of \verb'?time-interval1' is
 simultaneous with the end-point of \verb'?time-interval2', but
 the start-point of \verb'?time-interval1' is
  later than the start-point of \verb'?time-interval2.'

\end{itemize}

The next six Allen primitives are the inverses of the first six.


\begin{itemize}
\item{\verb'(after ?time-interval1 ?time-interval2)':}

%BEGIN IMAGE
\begin{picture}(200, 42)(-30,0)
\put(0,0){\framebox(200,37)}
\put (120, 22){\fbox {\scriptsize{\tt ?time-interval1}}}
\put (10, 10){\fbox {\scriptsize{\tt ?time-interval2}}}
 \end{picture}
%END IMAGE
%HEVEA\imageflush
 \newline The start-point of \verb'?time-interval1' is later
 than the end-point of \verb'?time-interval2'.


\item{\verb'(met-by ?time-interval1 ?time-interval2)':}

%BEGIN IMAGE
\begin{picture}(240, 42)(-30,0)
\put(0,0){\framebox(200,37)}
\put (100, 22){\fbox {\scriptsize {\tt ?time-interval1}}}
\put (30, 10){\fbox {\scriptsize {\tt ?time-interval2}}}
 \end{picture}
%END IMAGE
%HEVEA\imageflush
 \newline The start-point of \verb'?time-interval1' is
 simultaneous with the end-point of \verb'?time-interval2'.


\item{\verb'(overlapped-by ?time-interval1 ?time-interval2)':}

%BEGIN IMAGE
\begin{picture}(240, 42)(-30,0)
\put(0,0){\framebox(200,37)}
\put (80, 22){\fbox {\scriptsize {\tt ?time-interval1}}}
\put (50, 10){\fbox {\scriptsize {\tt ?time-interval2}}}
 \end{picture}
%END IMAGE
%HEVEA\imageflush
 \newline The start-point of \verb'?time-interval1' is
 between the start- and end-points of \verb'?time-interval2', but
the end-point of \verb'?time-interval1' is
 later than the end-point of \verb'?time-interval2'.

\item{\verb'(started-by ?time-interval1 ?time-interval2)':}

%BEGIN IMAGE
\begin{picture}(240, 42)(-30,0)
\put(0,0){\framebox(200,37)}
\put (60, 22){\framebox[3.2cm] {\scriptsize {\tt ?time-interval1}} }
\put (60, 10){\fbox {\scriptsize {\tt ?time-interval2}}}
 \end{picture}
%END IMAGE
%HEVEA\imageflush
 \newline The start-point of \verb'?time-interval1' is
 simultaneous with the start-point of \verb'?time-interval2', but
 the end-point of \verb'?time-interval1' is
  later than the end-point of \verb'?time-interval2.'


\item{\verb'(contains ?time-interval1 ?time-interval2)':}

%BEGIN IMAGE
\begin{picture}(240, 42)(-30,0)
\put(0,0){\framebox(200,37)}
\put (55, 22){\framebox[3.2cm] {\scriptsize {\tt ?time-interval1}} }
\put (65, 10){\fbox {\scriptsize {\tt ?time-interval2}}}
 \end{picture}
%END IMAGE
%HEVEA\imageflush
 \newline The start-point of \verb'?time-interval1' is
 earlier than the start-point of \verb'?time-interval2', but
 the end-point of \verb'?time-interval1' is
  later than the end-point of \verb'?time-interval2.'


\item{\verb'(finished-by ?time-interval1 ?time-interval2)':}

%BEGIN IMAGE
\begin{picture}(240, 42)(-30,0)
\put(0,0){\framebox(200,37)}
\put (55, 22){\framebox[3.2cm] {\scriptsize {\tt ?time-interval1}} }
\put (75.5, 10){\fbox {\scriptsize {\tt ?time-interval2}}}
 \end{picture}
%END IMAGE
%HEVEA\imageflush
 \newline The end-point of \verb'?time-interval1' is
 simultaneous with the end-point of \verb'?time-interval2', but
 the start-point of \verb'?time-interval1' is
  earlier than the start-point of \verb'?time-interval2.'

\end{itemize}

The thirteenth Allen primitive is the equality relation for time intervals.

\begin{itemize}
\item{\verb'(cotemporal ?time-interval1 ?time-interval2)':}

%BEGIN IMAGE
\begin{picture}(240, 42)(-30,0)
\put(0,0){\framebox(200,37)}
\put (65, 22){\fbox {\scriptsize {\tt ?time-interval1}} }
\put (65, 10){\fbox {\scriptsize {\tt ?time-interval2}}}
 \end{picture}
%END IMAGE
%HEVEA\imageflush
 \newline The start- and end-points of \verb'?time-interval1'
 and \verb'?time-interval2' are respectively simultaneous.  The relation is
 also called {\tt temporal}-{\tt bounds}-{\tt identical}.
\end{itemize}

As with the relations on time points, the Allen primitives are mutually
exclusive and exhaustive:  between any two time intervals, precisely one of
these relations holds.  Again, the relation \verb'cotemporal'
behaves like equality on time intervals for temporal reasoning, but it is not
a true equality relation.  In particular, it is possible for a non-temporal
relation to be true for one time interval but false for another cotemporal
one; two time-intervals can be cotemporal without being equal.

As with time points, \snark\  can efficiently draw conclusions about time
intervals from assertions expressed in terms of the Allen
primitives.  For example, suppose \verb'time-interval1' {\tt meets}
\verb'time-interval2', which in turn {\tt contains} \verb'time-interval3'.
The situation is illustrated as follows:



%BEGIN IMAGE
\begin{picture}(240, 60)(-30,0)
\put(0,0){\framebox(220,49)}
\put (30, 34){\fbox {\scriptsize {\tt ?time-interval1}}}
\put (100, 22){\framebox[3.2cm] {\scriptsize {\tt ?time-interval2}} }
\put (110, 10){\fbox {\scriptsize {\tt ?time-interval3}}}
 \end{picture}
%END IMAGE
%HEVEA\imageflush


\noindent Then
\snark\  can deduce that \verb'time-interval1' is before \verb'time-interval3'.


Note that if one time interval {\tt meets} another, the end-point of the first
interval must be {\tt simultaneous-with} the start-point of the second.
Because \snark\  doesn't identify a time interval with a set of points, it is
not meaningful to ask whether that time point is a member of either interval,
or whether those intervals have a point in common.


\subsubsection{Nonprimitive Relations}
\label{subsubsec-nonallen-temporal}

There are relations between time intervals other than the thirteen Allen
primitives in \snark\/.  The ones listed here are defined as disjunctions of
the Allen primitives, and hence are not logically necessary.  However, they
provide a useful and convenient abbreviation for commonly used notions; we
used them in our HPKB work.  The names are obtained from the CYC ontology
\cite{cyc}.

\begin{itemize}
  \item{\verb'(temporally-subsumes ?time-interval1 ?time-interval2)':}

Holds if \verb'?time-interval2' is a (not necessarily strict) subinterval of
\verb'?time-interval1', that is, if any of the following conditions holds:
\begin{verbatim}
  (finished-by ?time-interval1 ?time-interval2)
  (contains ?time-interval1 ?time-interval2)
  (cotemporal ?time-interval1 ?time-interval2)
  (started-by ?time-interval1 ?time-interval2)
\end{verbatim}
In other words, it is defined as the disjunction of \verb'finished-by',
 \verb'con'\-{\tt tains}, \verb'cotemporal', and \verb'started-'\verb'by'.

\item{\verb'(temporally-subsumed-by ?time-interval1 ?time-interval2)':}

  The inverse of {\tt temporally-subsumes}, it holds if {\tt ?time-interval1}
  is a subinterval of {\tt ?time-interval2}.  It is
  defined as the disjunction of {\tt starts}, {\tt cotemporal},  {\tt during},
  and {\tt finishes}, the inverses of the Allen primitives in the definition
  of {\tt temporally-subsumes}.

\item{\verb'(starts-during ?time-interval1 ?time-interval2)':}

  Holds if the start-point of \verb'?time-interval1' is (strictly) during
  \verb'?time'-{\tt interval2}.  It is defined as the disjunction of
  \verb'during', \verb'finishes' and {\tt overlapped-by}.

\item{\verb'(ends-during ?time-interval1 ?time-interval2)':}

  Holds if the end-point of {\tt ?time-interval1} is during {\tt
  ?time-interval2}.  If is defined as the disjunction of {\tt overlaps}, {\tt
  starts}, and {\tt during}.

\item{\verb'(starts-after-starting-of ?time-interval1 ?time-interval2)':}

 Holds if the start-point of {\tt ?time-interval1} is later than the
 start-point of {\tt ?time-interval2}.  If is defined to be the disjunction
 of {\tt during}, {\tt finishes}, {\tt overlapped-by}, {\tt met-by}, and {\tt
 after}.

\item{\verb'(ends-after-ending-of ?time-interval1 ?time-interval2)':}

 Holds if the end-point of {\tt ?time-interval1} is later than the end-point
 of {\tt ?time-interval2}.  It is defined to be the disjunction of {\tt
 contains}, {\tt started-by}, {\tt overlapped-by}, {\tt met-by}, and {\tt
 after}.

\item{\verb'(ends-after-starting-of ?time-interval1 ?time-interval2)':}

 Holds if the end-point of  {\tt ?time-interval1} is later than the start-point
 of {\tt ?time-interval2}.  It is defined to be the disjunction of all the
 Allen primitives except  {\tt before} and {\tt meets}.

\item{\verb'(temporally-cooriginating ?time-interval1 ?time-interval2)':}

 Holds if the start-points of  {\tt ?time-interval1} and {\tt
 ?time-interval2} are simultaneous.  It is defined to be the disjunction of
 {\tt starts}, {\tt cotem}\-{\tt poral}, and {\tt started-by}.

\item{\verb'(temporally-coterminal ?time-interval1 ?time-interval2)':}

 Holds if the end-points of  {\tt ?time-interval1} and {\tt
 ?time-interval2} are simultaneous.  It is defined to be the disjunction of
 {\tt finishes}, {\tt cotemporal}, and {\tt finished-by}.

\item{\verb'(temporally-disjoint ?time-interval1 ?time-interval2)':}

 Holds if {\tt ?time-interval1} and {\tt ?time-interval2} have no interior
 points in common.  It is defined to be the disjunction of the Allen
 primitives {\tt before}, {\tt meets}, {\tt met-by}, and  {\tt after}.

\item{\verb'(temporally-intersects ?time-interval1 ?time-interval2)':}

 Holds if  {\tt ?time-interval1} and {\tt
 ?time-interval2} are not disjoint, i.e., if they have some interior points
 in common.  It is defined to be the disjunction of
 all the Allen primitives except those in the definition of {\tt disjoint}.
 It is also called {\tt temporal-bounds-intersect}.


\end{itemize}

\subsection{Intermixing Temporal and Relational Reasoning}
\label{subsec-temporal-relational}
While it may be interesting to infer facts about temporal points and
intervals, the primary reason for including temporal reasoning in \snark\  is
to allow us to combine reasoning about temporal and other relations to
describe a changing world. In particular, we want to be able to talk about
relations that are true at some times and false at others.  One way to do
this is to allow those relations to have arguments that are time points or
time intervals.  For example, we might introduce a relation
\begin{verbatim}
  (possesses ?person ?object ?time-point)
\end{verbatim}
to mean the \verb'?person' owns \verb'?object' at \verb'?time-point',
and
\begin{verbatim}
  (possesses ?person ?object ?time-interval)
\end{verbatim}
to mean the \verb'?person' owns \verb'?object' during \verb'?time-interval'.

\Snark\   allows any relation to have arguments that are
time intervals or time points, but that is not necessarily interpreted to
 mean that the relation is true at that time point or during that time
 interval.  For instance, we might introduce a relation
\begin{verbatim}
  (hour-long ?time-interval)
\end{verbatim}
to mean that {\tt ?time-interval} is an hour long, not to mean that some
relation {\tt hour-long} is true during {\tt ?time-interval}.

 Furthermore, \Snark\  does not assume that, if a relation holds for a time
interval, it necessarily holds for any of the time points that occur during
that interval, or for its end-points.  Nor does it mean that the relation
holds for any subinterval of that interval.
 For instance, suppose the relation
\begin{verbatim}
  (profitable ?company ?time-interval)
\end{verbatim}
holds if {\tt ?company} makes a profit over the period \verb'?time-interval'.
 But that does not necessarily imply that {\tt ?company} makes a profit over
 every subinterval of {\tt ?time-interval}.  For instance, a company can be
 profitable over a year but have lost money for the first quarter of that
 year.

Let us say that a relation is {\em inherited by subintervals} if, whenever it
 holds for a time interval, it holds for every subinterval of that interval.
 Thus, the relation {\tt possesses} is inherited by subintervals but the
 relation {\tt profitable} is not.
 \Snark\/ will not assume that a relation is inherited by subintervals unless
 we introduce an assertion that says so.  To say that {\tt
 possesses} is inherited by subintervals, we may introduce the assertion
\begin{verbatim}
  (assert
   '(implies
     (temporally-subsumes ?time-interval1 ?time-interval2)
     (implies
      (possesses ?person ?object ?time-interval1)
      (possesses ?person ?object ?time-interval2)))
   :name
    'possession-inherited-by-subintervals)
\end{verbatim}

Now suppose we would like to say that George possessed the Maltese Falcon
during a certain period of time, say ``the good old days.''  Then we can
give the assertion
\begin{verbatim}
  (possesses george the-maltese-falcon good-old-days)
\end{verbatim}
Because {\tt possesses} is inherited by subintervals, this will imply that
George possessed the Maltese Falcon during every subinterval of the good old
days.

Now suppose we want to say that the good old days is the only time in which
George possessed the Falcon.  To say this in terms of the Allen logic,
mentioning time intervals but not time points, we may say that George
did not possess the Falcon in any time interval other than the subintervals
of the good old days.
\begin{verbatim}
  (assert
   '(implies
     (not (temporally-subsumes good-old-days ?time-interval))
     (not (possesses george the-maltese-falcon ?time-interval)))
   :name 'george-does-not-possess-maltese-falcon-other-times)
\end{verbatim}
Then if a period of hard times
occurred later than the good old days, that is, if we have
\begin{verbatim}
  (assert '(before good-old-days hard-times)
          :name 'good-old-days-before-hard-times)
\end{verbatim}
then \snark\  will be able to establish
\begin{verbatim}
  (prove
    '(not (possesses george the-maltese-falcon hard-times)))
\end{verbatim}

\subsection{Mixed Point-Interval Relations}
\label{subsec-temporal-point-interval}

We have talked about temporal relations between pairs of time points and
temporal relations between pairs of time intervals.  In \snark\  there are
also {\em mixed} temporal relations, between time points and time intervals
and between time intervals and time points.  This is a useful extension of the
Allen temporal logic.

The mixed relations have the same names as some of the point-point and
interval-interval relations.  Their meanings are analogous.

\subsubsection{Point-Interval Relations}
Some of these mixed relations hold only between a time point and a time
interval, where the time point must be the first argument.

\begin{itemize}

\item{\verb'(starts ?time-point ?time-interval)':}

 Holds if {\tt ?time-point} is simultaneous with the start-point of
 {\tt ?time}-{\tt interval}.

\item{\verb'(finishes ?time-point ?time-interval)':}

 Holds if {\tt ?time-point} is simultaneous with the end-point of
 {\tt ?time}-{\tt interval}.

\item{\verb'(during ?time-point ?time-interval)':}

 Holds if {\tt ?time-point} is strictly between the start- and end-point of
 {\tt ?time-interval}.
\end{itemize}

\subsubsection{Interval-Point Relations}
The inverses of the point-interval relations hold only between an interval
and a point, where the point must be the second argument.

\begin{itemize}

\item{\verb'(started-by ?time-interval ?time-point)':}

 Holds if {\tt ?time-point} is simultaneous with the start-point of {\tt
 ?time}-{\tt interval}.

\item{\verb'(finished-by ?time-interval ?time-point)':}

 Holds if {\tt ?time-point} is simultaneous with the end-point of {\tt
 ?time}-{\tt interval}.

\item{\verb'(contains ?time-interval ?time-point)':}

 Holds if {\tt ?time-point} is strictly between the start- and end-points of
 {\tt ?time}-{\tt interval}.

\end{itemize}


 Of the mixed relations, {\tt before} and {\tt after} allow points and
intervals in either argument.
%% We will use {\tt ?time} to stand for a term
%% that can be either, with the understanding that one argument is a time point
%% and the other is a time interval.

\begin{itemize}

\item{\verb'(before ?time-point ?time-interval)':}

  Holds if {\tt ?time-point} is strictly earlier
  than the start-point of {\tt ?time}-{\tt interval}.

\item{\verb'(before ?time-interval ?time-point)':}

  Holds if the end-point of
  {\tt ?time-interval } is strictly earlier than {\tt ?time}-{\tt point}.

\item{\verb'(after ?time-point ?time-interval)':}

  Holds if {\tt ?time-point} is strictly later than the end-point of
  {\tt ?time}-{\tt interval}.

\item{\verb'(after ?time-interval ?time-point)':}

  Holds if the start-point of {\tt ?time-interval} is strictly later than
  {\tt ?time}-{\tt point}.

\end{itemize}

Some of the temporal primitives have no corresponding mixed relations.  The
equality relations {\tt cotemporal} and {\tt simultaneous-with} are not
defined on mixed arguments, because a time point can never be temporally
equal to a time interval.  The relations {\tt meets}, {\tt met-by}, {\tt
overlaps}, and {\tt overlapped-by} are not necessary for mixed arguments,
because the concepts they would stand for are either nonsensical or already
have other names.  For instance, to say that a time point {\tt meets} a time
interval would be equivalent to saying that it {\tt starts} the time
interval.  And it doesn't make sense for a time point to overlap a time
interval.

\subsubsection{Nonprimitive mixed relations}

Some of the nonprimitive temporal relations can be used between an interval
and a point, or between a point and an interval, including

\begin{itemize}

  \item{\verb'(temporally-intersects ?time-interval ?time-point)':}

 \item{\verb'(temporally-intersects ?time-point ?time-interval)':}

  These relations are inverses.  Both hold if {\tt ?time}-{\tt point}
  occurs, not necessarily strictly, in {\tt ?time}-{\tt interval}.  That is,
  {\tt ?time-point} is simultaneous with the start- or end-point of {\tt
  ?time}-{\tt interval} or is between those two time-points.
\end{itemize}

To summarize, a single Allen-style temporal reasoning system is used for all
relations among points and intervals.
\begin{itemize}
 \item There are three exhaustive, mutually
exclusive relations between time points ({\tt simultaneous}-{\tt with}, {\tt
before}, and {\tt after}).

 \item There are thirteen exhaustive, mutually exclusive relations between time
intervals, given in Section \ref{subsubsec-allen-primitives}.

 \item There are five exhaustive, mutually exclusive relations between a time
point and a time interval ({\tt before}, {\tt starts}, {\tt during}, {\tt
finishes}, and {\tt after}), and their five inverses, which are relations
between a time interval and a time point ({\tt after}, {\tt started-by}, {\tt
contains}, {\tt finished-by}, and {\tt before}).
\end{itemize}
Thus, all in all there are twenty-six primitive relations between temporal
entities.
\subsection{Temporal Functions}

The temporal reasoning package defines functions that are useful for
mapping time intervals and time-points into others.  They include

\begin{itemize}

 \item{\verb'(start-fn ?time-interval)':}

 The start-point of {\tt ?time-interval}.

 \item{\verb'(end-fn ?time-interval)':}

 The end-point of {\tt ?time}-{\tt interval}.

 \item{\verb'(time-interval ?time-point1 ?time-point2)':}

 The time interval from {\tt ?time}-{\tt point1} to {\tt ?time}-{\tt point2}.
 That is, the start-point of the interval is {\tt ?time}-{\tt point1} and the
 end-point is {\tt ?time}-{\tt point2}.  Here {\tt ?time}-{\tt point1} must
 be before {\tt ?time}-{\tt point2}.

 \item{\verb'(time-interval-ip ?time-interval ?time-point)':}

  The time interval from the start-point of {\tt ?time-interval} to {\tt
  ?time}-{\tt point}.  It is assumed that the start-point
  is before {\tt ?time}-{\tt point}.

 \item{\verb'(time-interval-pi ?time-point ?time-interval)':}

  The time interval from {\tt ?time}-{\tt point} to the end-point of {\tt
  ?time}-{\tt inter}\-{\tt val}.  It is assumed that {\tt ?time}-{\tt point} is
  before the end-point.


 \item{\verb'(time-interval-ii ?time-interval1 ?time-interval2)':}

 The time interval from the start-point of {\tt ?time}-{\tt interval1} to the
 end-point of {\tt ?time}-{\tt interval2}.  It is assumed that the start-point
 comes before the end-point.

\end{itemize}

\subsection{Point-Interval Temporal and Relational Reasoning}
\label{subsec-mixed-temporal-relational}

The reason to introduce the mixed point-interval temporal relations is that
reasoning about a changing world is more natural if we can talk about both
points and intervals.  For instance, it made sense (in Section
\ref{subsec-temporal-relational}) when we asserted that George possessed the
Maltese Falcon during the good old days, but it was a bit artificial when we
said that
 George did not possess the Falcon during any time interval not
temporally subsumed by the good old days.

It might have been more natural to use mixed time intervals and time points
to express the same properties.  For instance, let us say that a relation
is {\em inherited by sub-points}  if, whenever that relation holds for a
time interval, it also holds for every time point that  temporally intersects
that interval.  Note that a relation may be inherited by subintervals, as
we discussed in  \ref{subsec-temporal-relational}, but not inherited by
sub-points, and vice versa.

 We can say that the relation {\tt possesses} is inherited by
sub-points by introducing the assertion
\begin{verbatim}
  (assert
   '(implies
     (temporally-intersects ?time-interval ?time-point)
     (implies
      (possesses ?person ?object ?time-interval)
      (possesses ?person ?object ?time-point)))
   :name
   'possession-inherited-by-sub-points)
\end{verbatim}
And we can say further that George does not possess the Falcon at any time
point that does not occur during the good old days:
\begin{verbatim}
  (assert
   '(implies
     (not (temporally-intersects good-old-days ?time-point))
     (not (possesses george the-maltese-falcon ?time-point)))
   :name 'george-doesnt-possess-maltese-falcon-other-times
\end{verbatim}
And finally we can say that the special time point {\tt now} is later than
the good old days:
\begin{verbatim}
  (assert '(before good-old-days now)
          :name 'good-old-days-before-now)
\end{verbatim}
Note that all these assertions use temporal relations between time intervals
and time points.  From these assertions \snark\   can establish
\begin{verbatim}
  (prove '(not (possesses george the-maltese-falcon now)))
\end{verbatim}

\subsection{Calendar Dates and Clock Times}

\Snark\  has a built-in representation of dates on the calendar and times on
the clock, and this representation is integrated into the temporal inference
procedure.  For example, \snark\  knows that December 31, 1999 meets January
1, 2000, in Allen's sense of ``meets'', and that 11PM on the former date is
before 1AM on the latter date.

%%Calendar dates are a frequently used aspect of temporal knowledge.  It
%%is possible to support efficient reasoning between calendar dates,
%%because many inferences about calendar dates can be reduced to
%%comparisons of universal time.

\Snark\  supports the following date
functions, which are based on the Cyc ontology \cite{cyc-ul}.
\begin{itemize}

 \item{\verb'(year-fn ?integer)':}

The time interval corresponding to the year {\tt ?integer}.  For example, {\tt
(year-fn 1999)} is the time interval with start-point 00:00:00 hours on
January 1, 1999, and end-point 00:00:00 hours on January 1, 2000.


 \item{\verb'(month-fn ?integer ?year)':}

The time interval corresponding to the month numbered {\tt ?integer}, between
1 and 12; e.\ g., {\tt (month-fn 5 (year-fn 1999))}.  The month-fn function
also accepts the names of the months, e.\ g.\, {\tt (month-fn May (year-fn
1999))}.

 \item{\verb'(day-fn ?integer ?month)':}

The time interval corresponding to the calendar day {\tt ?integer} of {\tt
?month}.  For example, {\tt (day-fn 10 (month-fn 5 (year-fn 1999)))}
represents the time interval corresponding to May 10, 1999. Here {\tt
integer} must be at least 1; no promises are
made about what happens if {\tt ?integer} is larger than the number of days in
the month.

 \item{\verb'(hour-fn ?integer ?day)':}

The time interval corresponding to the hour {\tt ?integer} of {\tt ?day}.
For example, {\tt (hour-fn 11 (day-fn 10 (month-fn 5 (year-fn 1999))))}
represents the interval defined by 11:00 AM, May 10, 1999.  \Snark\  uses a
24-hour day; {\tt ?integer} should be between 0 and 23.  \Snark\  does not know
about time zones; all times should be in the same time zone, but it does not
matter which.


 \item{\verb'(minute-fn ?integer ?hour)':}

The time interval corresponding to the minute {\tt ?integer} of {\tt ?hour},
where {\tt ?integer} is between 0 and 59.
For example, {\tt (minute-fn 12 (hour-fn 11 (day-fn 10 (month-fn 5 (year-fn
1999)))))} represents the interval defined by 11:12 AM, May 10, 1999.  The
interval starts at 12 minutes after the hour, and continues until 13 minutes
after the hour.


 \item{\verb'(second-fn ?integer ?minute)':}

The time interval corresponding to the second numbered {\tt ?integer} of {\tt
?minute}, where {\tt ?integer} is between 0 and 59.  For example, {\tt
(second-fn 13 (minute-fn 12 (hour-fn 11 (day-fn 10 (month-fn 5 (year-fn
1999))))))} represents the interval starting 11:12:13 A.M., May 10, 1999 and
continuing until 11:12:14 on the same day.
\end{itemize}

\subsection{Dates in Other Time Intervals}

It is quite common to specify dates in a non-calendar time interval; for
example, ``The President made a statement on the third day of the war.''
\Snark\  supports such reasoning by an extension of the function {\tt day-fn},
described as follows:

\begin{itemize}
 \item{\verb'(day-fn ?integer ?constant)':}

The fifth day of the time interval corresponding to {\tt ?constant}.  For
example, {\tt (day-fn 5 scenario)} represents the fifth day in {\tt
scenario}.  It is understood that {\tt scenario} is supposed to correspond to
a time interval, but \snark\  does not enforce that.  The date reasoning
procedure is unable to compare dates between two different non-calendar time
intervals, even if temporal relations are known between the two intervals.
For instance, even if we assert {\tt (before the-civil-war
the-age-of-aquarius)}, \snark\  will not know that {\tt (before (day-fn 1
the-civil-war) (day-fn 2 the-age-of-aquarius))}.

\end{itemize}

\subsection{Temporal Reasoner Interface}

The interface between \snark\  and the Allen temporal-reasoning procedure uses
constraint resolution \cite{burckert}.  Each row is split between ;

If a pure temporal relation between two ground (i.\ e., variable-less) terms is
asserted or deduced, it is introduced into a graph representation of all
known temporal relations.  If the relation already follows from the relations
in the graph, the graph is not changed. If the relation contradicts what is
already known in the graph, a contradiction has been deduced and the proof is
complete.

If a more complex formula is asserted of deduced, it is split between a
logical part and a temporal constraint, which are kept in the same row.
The constrained row means that if
some instance of the temporal constraint is satisfied,  the corresponding
instance of the logical part is true.


For example, suppose a proof contains the row
\begin{verbatim}
(Row 137
   (possesses george the-maltese-falcon ?time-interval)
   Temporal-Constraint
    (ii%temporally-subsumes good-old-days ?time-interval)).
\end{verbatim}
Here \verb'ii%temporally-subsumes' is the graph representation of the relation
{\tt temporally-subsumes}.  This row means that if the good-old-days interval
temporally subsumes {\tt ?time-interval}, then George possesses the Maltese
Falcon during {\tt ?time-interval}.



Deduction rules applied to constrained rows generate a new row, which
contains both a logical part and a temporal constraint.
 When the temporal constraint is ground, the graph representation of all known
temporal constraints is used to see if the constraint is satisfied;  if so,
the constraint is removed.  If the constraint contradicts the known temporal
relationships, the entire row is discarded.


The link between the Allen relations that appear in formulas and their
corresponding graph representations is achieved by a number of assertions
that are added automatically by \snark\/.  For example:
\begin{verbatim}
(Row ~ii%temporally-subsumes
   (not (temporally-subsumes ?time-interval ?time-interval1))
   assertion
   Temporal-Constraint
    (not
     (ii%temporally-subsumes ?time-interval ?time-interval1))).
\end{verbatim}
This asserts that if the graph representation of the relation {\tt
temporally}-{\tt subsumes} is satisfied, the relation itself holds.  Applying
the resolution rule to this assertion and a formula that mentions the
relation will have the effect of removing the relation from the formula and
adding it to the temporal constraint.

The proof is complete when \snark\  has discovered a contradiction in the
logical parts of the rows, and when the corresponding temporal constraints
are also satisfied.  Should \snark\  deduce a contradictory row {\tt false}
whose corresponding temporal constraints cannot be satisfied, the row is
discarded and the search continues.


\section{Procedural Attachment}
\label{sec-procedural-attachment}

We have seen that, for some areas such as temporal reasoning, it is
advantageous to use special-purpose inference procedures rather than to rely
on only \snark\/'s general-purpose inference rules.  It is impossible,
however, for \snark\  to include every special-purpose procedure that may be
useful for some application.  Instead, \snark\  includes a procedural
attachment facility that allows a user to invoke external procedures as part
of the standard resolution.

There are two principal ways to introduce procedural attachments, by
intervening in either the rewriting mechanism or the resolution mechanism.
We treat each separately.  (There is also a way to use procedural attachment
via the paramodulation rule.)

\subsection{Rewrite Code}
\label{subsec-rewrite-code}

The rewrite-code mechanism allows the user to provide external code to
rewrite expressions, much as a rewrite rule does.  This code is
associated with particular function or predicate symbols.

\subsubsection{Built-in Rewrite Code}
\Snark\   already has built-in procedural attachments, in the form of rewrite
code, for important arithmetical, symbolic, and list-processing functions.
For instance, if there were no procedural attachment mechanism, the only way
we would be able to add two numbers would be to reason from the axioms for
addition, a rather ponderous business.  However,
if we select the option {\tt use}-{\tt code}-{\tt for}-{\tt
numbers}, arithmetic operations will be carried out by the corresponding
\lisp\   code.  In particular, a term \verb'(+ 2 2)' will be immediately
rewritten as {\tt 4}, without invoking any axioms or inference rules.
\Snark\   has procedural attachments for  the principal arithmetic function and
predicate symbols in the \ansi\  \kif\  \commonlisp\  library.  Similarly,
selecting the options {\tt use}-{\tt code}-{\tt for}-{\tt lists} and {\tt
use}-{\tt code}-{\tt for}-{\tt characters} will give \snark\  access to
 \ansi\  \kif\  \commonlisp\/'s list and character libraries.

The \snark\   equality function is also rewritten by a built-in procedural
attachment.  For instance, a formula of form \verb'(= <term> <term>)', where both
arguments are alike, will be automatically rewritten to {\tt true}.

A procedure can be attached to a user-defined \snark\  function or predicate
symbol by means of its declaration.  Some built-in procedures can be attached
to user-defined symbols.  For example, suppose we wish to declare that the
relation  {\tt near} is reflexive, that is, that a place is to be regarded as
near to itself.  Then we may include the declaration
\begin{verbatim}
  (declare-predicate-symbol
    'near 2 :rewrite-code 'reflexivity-rewriter)
\end{verbatim}
in addition to whatever other declarations are given for the predicate symbol
{\tt near}.  The program {\tt reflexivity-rewriter} is \lisp\  code built into
\snark\  that performs a rewriting analogous to the one we have described for
equality.  In using this rewriting in the course of a proof, \snark\  will
report {\tt rewrite} \ldots {\tt :code}-{\tt for}-{\tt near} in the
explanation.

\subsubsection{User-Supplied Rewrite Code}
 Let us look at the program {\tt reflexivity-rewriter} described in the
previous section; then we can describe the constructs necessary to understand
it and to build analogous rewrite code for our own theories.
\begin{verbatim}
(defun REFLEXIVITY-REWRITER (atom subst)
  (let ((args (args atom)))
    (if (equal-p (first args) (second args) subst) true none)))
\end{verbatim}

This program tests if, after applying the substitution {\tt subst}, the two
arguments of the formula {\tt atom} are equal; if so, it returns {\tt true};
otherwise, it returns the special symbol {\tt :none}, which indicates that
the formula is not to be rewritten.  (The \lisp\   variable {\tt none}
has value {\tt :none}.)

Every piece of rewrite code has two arguments, an expression and a
substitution, here called {\tt atom} and {\tt subst} respectively.
The actual expression being simplified is the result of applying {\tt subst}
to {\tt atom}.  For example, if {\tt atom} is \verb'(near ?place ohio)'
and {\tt subst} is a substitution that replaces {\tt ?place} with {\tt ohio},
the actual expression being substituted is \verb'(near ohio ohio)'.  For
reasons of efficiency, \Snark\   sometimes
carries around the substitution rather than applying it.

The following \lisp\   functions are defined in \snark\  and are useful for
writing procedural attachments.

\begin{description}

 \item{{\tt :none}:}

 As mentioned above, a special symbol that can be returned by a rewrite rule to
 indicate that the expression is not to be rewritten by that rule.  The
 \lisp\  variable {\tt none} is assigned the value {\tt :none}.

 \item{\verb'(head exp)':}

 The principal function or predicate symbol of the expression {\tt exp}.

 \item{\verb'(args exp)':}

 The argument list of the expression {\tt exp}.

 \item{\verb'(equal-p exp1 exp2 subst)':}

 A test which is true if applying the substitution {\tt subst} to the
 expressions {\tt exp1} and {\tt exp2} yields identical expressions, false
 otherwise.
\end{description}

A more complex construct is
\begin{verbatim}
  (dereference exp subst
    :if-constant const-code
    :if-variable var-code
    :if-compound comp-code)
\end{verbatim}
The construction applies the substitution {\tt subst} to the expression {\tt
exp} and evaluates {\tt exp}.   Then
\begin{description}

 \item{{\mbox{}}} If the result is a constant, it evaluates the \lisp\
  expression {\tt const-code}.

 \item{{\mbox{}}} If the result is a variable, it evaluates the \lisp\
  expression {\tt var-code}.

 \item{{\mbox{}}} If the result is a compound expression, such as the
  application of a function symbol to arguments, it evaluates the \lisp\
  expression {\tt comp-code}.

\end{description}
In each case, the value of the entire {\tt dereference} expression is the
  value of the evaluated subexpression.  Any of the keyword cases can be
  omitted, and their order is inconsequential.  In case none of the given
  keywords is applicable, the value of the {\tt dereference} expression is
  {\tt nil}.

\subsubsection{Example: Rewrite Code for {\tt mother}}

Let us use some of these constructs in the family theory to introduce rewrite
code for the function {\tt mother}.  Suppose there is a \lisp\   function {\tt
mother-fun} that can compute the mother of any constant of sort {\tt person};
for instance, {\tt mother-fun} might consult external genealogical tables for
this purpose.  We would like to attach this program to the function symbol
{\tt mother} in our family theory.

First we indicate that the symbol {\tt mother} is to be given a procedural
attachment in the form of rewrite code.
\begin{verbatim}
  (declare-function-symbol 'mother 1
                           :rewrite-code 'mother-rewriter)
\end{verbatim}
Then we define the \lisp\ function {\tt mother-rewriter}
    to extract the argument {\tt arg} from terms of form \verb'(mother arg)',
    where {\tt arg} is a constant, and to invoke {\tt mother-fun} on that
    constant:
\begin{verbatim}
  (defun MOTHER-REWRITER (term subst)
    (let ((child (first (args term))))
      (dereference child subst
                   :if-constant
                   (mother-fun child)
                   :if-variable none
                   :if-compound none)))
\end{verbatim}
Note that this will have no effect on terms of form \verb'(mother arg)',
where {\tt arg} is a variable or a compound term.  Also, we are assuming that
all the constant symbols returned by {\tt mother}-{\tt fun} have already been
declared to be of sort {\tt woman} (and hence {\tt person}); if new names are
introduced by {\tt mother}-{\tt fun}, they must be declared by {\tt
mother}-{\tt rewriter}.  For example, the preceding \lisp\  function might be
revised to include the expression
\begin{verbatim}
  (declare-constant-symbol (mother-fun child) :sort 'woman)
\end{verbatim}

Given this procedural attachment, \snark\  can answer queries such as
\begin{verbatim}
  (prove
   '(and (= ?woman (mother ?person))(parent ?person carol))
   :answer '(ans ?woman))
\end{verbatim}
where all the information it has about the mothers of individual constants is
given by the function {\tt mother-fun}.  \Snark\  will behave as if all this
information were stored as rewrite rules.  For instance, suppose
\begin{verbatim}
  (mother-fun carol) = betty
\end{verbatim}
and
\begin{verbatim}
  (mother-fun betty) = alice
\end{verbatim}
Then \snark\  will include {\tt alice} among its answers for the above query.
Use of {\tt mother-fun} in the proof will be justified by the annotation
 {\tt rewrite} \ldots {\tt :code}-{\tt for}-{\tt mother} in the explanation.

Procedural attachments can coexist with axioms.  Thus, we might have axioms
about {\tt mother-fun} as well as the procedural attachment.

\subsection{Satisfy and Falsify Code}

The same limitations that apply when information is represented by rewrite
rules also applies when information is stored in rewrite code.  For instance,
we cannot use the rewrite code for mother to answer the query
\begin{verbatim}
  (prove
   '(= betty (mother ?person))
   :answer '(ans ?person)
   :name 'whose-mother-is-betty?)
\end{verbatim}
Although the procedural attachment can rewrite \verb'(mother carol)' to {\tt
betty}, it has no effect on the term \verb'(mother ?person)'.  In fact,
because of the one-way nature of a function, we cannot use a procedural
attachment to a function symbol to answer this kind of question.  We can,
however, use the {\em satisfy-} and {\em falsify-code} mechanisms, which
allow a procedural attachment to intervene in the resolution mechanism.  We
introduce these with an example.

\subsubsection{Satisfy Code for mother}

Suppose that, in addition to the {\tt mother} function symbol, we also
introduce a two-place {\tt mother} predicate symbol.  Imagine that we have a
table of mother-child pairs, e.g.,
\begin{verbatim}
  (defvar MOTHER-TABLE
    '((alice betty)
      (alice barbara)
      (betty carol)
      (betty claudia)
      ))
\end{verbatim}
In other words, Alice is the mother of Betty, Alice is the mother of Barbara,
and so forth.   Then we can use the satisfy-code mechanism to make \snark\
behave as if it had been given the corresponding atomic assertions
\begin{verbatim}
  (assert '(mother alice betty))

  (assert '(mother alice barbara))

  (assert '(mother betty carol))

  (assert '(mother betty claudia))
\end{verbatim}
We do this by attaching to the predicate symbol {\tt mother} a procedure
that, whenever \snark\ is trying to establish the truth of a formula of form
{\tt (mother person1 person2)}, will cycle through
 {\tt mother}-{\tt table} and attempt to unify the pair
\verb'(person1 person2)' with successive pairs of the table.

First we indicate that the predicate symbol {\tt mother} is given a
procedural attachment in the form of satisfy code:
\begin{verbatim}
  (declare-predicate-symbol 'mother 2
    :satisfy-code 'mother-satisfier)
\end{verbatim}
Then we provide a \lisp\  function {\tt mother}-{\tt satisfier} that will
attempt to unify the arguments of the formula against the successive pairs
of the table:
\begin{verbatim}
  (defun MOTHER-SATISFIER (cc atom subst)
    (let ((args (args atom)))
      (mapc
       (lambda (pair) (unify cc args pair subst))
       mother-table)))
\end{verbatim}
Here each pair in {\tt mother}-{\tt table} is unified with the pair of
arguments of the formula under consideration.  Note that {\tt mother}-{\tt
satisfier}, like all satisfy code, has a continuation {\tt cc} as its first
argument.  The continuation is a function that, when called, will attempt to
complete the rest of the proof.  If {\tt unify} succeeds in unifying {\tt
args} with {\tt pair}, it will then invoke the continuation {\tt cc}, passing
on whatever substitutions {\tt unify} has discovered.

Once we have provided this procedural attachment, \snark\  can use the table
to provide answers to the query
\begin{verbatim}
  (prove
   '(mother betty ?person)
   :answer '(ans ?person)
   :name 'who-is-bettys-child?)
\end{verbatim}
Invoking this query once will provide one answer, Carol.  Then executing
\verb'(closure)' will send \snark\  back into the table to find another
answer, Claudia.

While introducing a procedural attachment for such a small table gives no
benefit, it is reasonable to introduce procedural attachments for large
tables and it is unavoidable if the table can only be accessed via an
external function call or a web access.

\subsubsection{Falsify code for {\tt mother}}

Satisfy code allows us to establish that a relation is true as the result of
executing a procedure.  Sometimes, however, a procedure can tell us that the
relation is false.  To invoke such a procedure, we use {\em falsify code}.

For instance, suppose we want to introduce code to embody the idea that the
relation {\tt mother} is irreflexive, i.\  e., that a person cannot be her own
mother.  One could do this by introducing an assertion
\begin{verbatim}
  (assert
   '(not (mother ?person ?person))
   :name 'mother-is-irreflexive)
\end{verbatim}
Alternatively, we can introduce falsify code to have the same effect as
resolution against the above assertion.

For this purpose, we declare the predicate symbol {\tt mother} to have
falsify code {\tt mother-falsifier}:
\begin{verbatim}
  (declare-predicate-symbol 'mother 2
    :falsify-code 'mother-falsifier)
\end{verbatim}
Note that the same symbol can have satisfy code, falsify code, and rewriting
code.

We define the \lisp\  function {\tt falsify-code} as
\begin{verbatim}
  (defun MOTHER-FALSIFIER (cc atom subst)
    (let ((args (args atom)))
      (unify cc (first args) (second args) subst)))
\end{verbatim}
Here, again, {\tt cc} is continuation code that attempts to complete the
proof.
This function will be invoked when a formula {\tt (mother person1 person2)}
occurs in a context in which we are trying to prove that it is false, e.\  g.,
in a query of form
\begin{verbatim}
  (prove
   '(not (mother person1 person2)))
\end{verbatim}
where {\tt person1} and {\tt person2} are terms that may have variables.  It
will attempt to unify {\tt person1} and {\tt person2}.  If it succeeds, {\tt
unify} will call the continuation code {\tt cc}, passing on whatever
substitutions it has discovered, in an attempt to complete the proof.  If
{\tt unify} fails, {\tt mother}-{\tt falsify} returns and other avenues to
complete the proof are sought.

Actually, \snark\  has general-purpose code for declaring a relation to be
irreflexive and introducing the appropriate falsify code.  So, to declare
the predicate {\tt mother} to be irreflexive, we could obtain the same effect
simply by introducing the declaration
\begin{verbatim}
  (declare-predicate-symbol 'mother 2
    :falsify-code 'irreflexivity-falsifier)
\end{verbatim}


%%Satisfy code can establish that a relation is true when it appears in a table,
%%but it cannot establish that the relation is false when it fails to appear;
%%that kind of inference requires us to make a kind of {\em closed world
%%assumption}.  For example, if our {\em mother-table} was a complete list of
%%all the mother-child relationship between all the people in our vocabulary,
%%we would want to be able to conclude that {\tt (not (mother person1
%%person2))} from the fact that the pair {\tt (person1 person2)} did not appear
%%in the table.




\section{Support for \kif\//\okbc\   Users}
\label{sec-kif-snark}

Knowledge Interchange Format (\kif\  ) is a language designed for use in
the interchange of knowledge amongst disparate computer systems
\cite{kif}. \Kif\   was a result of a community effort and a draft of the
\kif\   specification is under consideration as an \ansi\  standard.  Open
Knowledge Base Connectivity (\okbc) is an application programming
interface for accessing knowledge representation systems. \Okbc\   interfaces
to many popular knowledge representation systems exist.

Given such a broad base of \kif\   and \okbc\   users, \snark\  supports input
of axioms in a language called \kifsnark (``\kif\  plus
Classes''). \kifsnark\  uses the \ansi\  draft \kif\   syntax for writing
axioms, and recognizes some standard relation names from the \okbc\
knowledge model.

The \kifsnark\  not only makes it easier for \snark\  to do knowledge
sharing with other systems, but also implements a connection between
three ways of representing classes of entities in
\snark\/: through sorts, through sets, and through predicate symbols.  In
this section we introduce this way of presenting information to \snark\/.

\subsection{Introduction to \Kif}

\Kif\  has declarative semantics, is logically comprehensive with its
support for arbitrary logical sentences, and supports representation
of knowledge about knowledge.

\Kif\   accepts sentences built up of constants, function and predicate symbols,
logical connectives, and quantifiers.  \Kif\  accepts the equality
symbol \verb'=', the connectives \verb'and', \verb'or', \verb'not',
and the quantifiers \verb'forall' and \verb'exists'.



Function and relation symbol may occur with different arities.
\kif\/ assumes that if the same symbol occurs with varying arity, all those
occurrences stand for the same function, and the function itself has
variable arity.

\Kif\  has three directions of implication connective, \verb'=>', \verb'<='
and \verb'<=>'.

Free variables in assertions have tacit universal quantification,
while free variables in queries have tacit existential quantification.

\Kif\  has four constructs for defining new symbols:

\begin{description}
 \item[defobject] Introduces a new constant, standing for a thing or entity.

 \item[defrelation] Introduces a new predicate symbol, standing for a
 relation.

 \item[deffunction] Introduces a new function symbol, standing for a
 function.

 \item[deflogical]  Introduces a new propositional symbol, standing for a
 truth-value.
\end{description}



\subsection{Description of \kifsnark}

The domain of discourse for the \kifsnark\  consists of individuals,
relations, functions, and assertions.  Unary relations are identified with
classes.  We consider each of these, beginning with classes, which are given
special treatment in \kifsnark\  because they are tied to \snark\/'s sort
mechanism.

To enable the \kifsnark\  interface, we place the following statement
at the top of our source files:
\begin{verbatim}
  (in-language :hpkb-with-ansi-kif)
\end{verbatim}
or
\begin{verbatim}
  (in-language :hpkb-with-kif-3.0)
\end{verbatim}
All the examples in this section will work with either version of the \kif\
interface.


\subsubsection{Declaring Classes}
\label{subsec-kif-class}

A class in \kifsnark\  corresponds to  a set, and a unary predicate
symbol (i.\  e., a predicate symbol of arity 1).  It is declared
with the construct \verb'defrelation'.

For instance, to declare a class,
\verb'person', we execute
\begin{verbatim}
  (defrelation person
    (class person))
\end{verbatim}
The relation name \verb'class' is a standard name derived from the \okbc\
knowledge model.

The declaration constructs each allow an optional string as their first
argument, which can be used for documentation:
\begin{verbatim}
  (defrelation object
      "Collection of all objects."
    (class object))
\end{verbatim}
Specifying documentation string as an optional first argument is
allowed in the \ansi\ version of \kif\/, but not in \kif\  3.0.

Within the \verb'defrelation' construct we can provide many declarations and
axioms related to the class being declared.  For instance, we can declare that
one class is a subclass of another:
\begin{verbatim}
  (defrelation man
      "Collection of all men."
    (class man)
    (subclass-of man person))
\end{verbatim}
This construct introduces a new class \verb'man' and declares that
{\tt man} is a subclass of {\tt person}, i.\  e., that every man is
also a person.  The relation name \verb'subclass-of' is a standard
relation name based on the \okbc\   knowledge model.

It is a convention (which \snark\  does not enforce) that the
statements included in a declaration be relevant to the entity being
declared; in particular, it is recommended that a subclass declaration
\verb'(subclass-of man ...)' should appear in the declaration for the class
\verb'man', rather
than elsewhere.


\subsubsection{Declaring Individuals}
\label{subsec-kif-individuals}
If we want to introduce an individual that is not itself a set, we use the
construct \verb'defobject'.  For instance,
\begin{verbatim}
  (defobject george
    (instance-of george man))
\end{verbatim}
introduces a constant \verb'george' that is of sort \verb'man' and an
element of the set \verb'man'.  Here \verb'instance-of' corresponds to
the set membership relation, and is a standard relation name derived
from the \okbc\   knowledge model.

The predicate symbols \verb'subclass-of' and \verb'instance-of' are given
special treatment in \snark\/.   In particular, when the class \verb'person'
is declared, an assertion
\begin{verbatim}
  (instance-of ?person person)
\end{verbatim}
is automatically introduced; in other words, any term of sort \verb'person'
stands for an element of the set \verb'person'.  Also, any formula of form

\begin{verbatim}
  (person <term>)
\end{verbatim}
where \verb'<term>' is a term, is automatically rewritten as
\begin{verbatim}
  (instance-of <term> person).
\end{verbatim}
Thus, any use of \verb'person' as a predicate symbol is automatically
translated into a use of \verb'person' as a set.

Special procedures are built into \snark\  to take into account the
class, subclass, and object declarations during a proof.  For instance,
with the above declarations, that \verb'george' is a \verb'man' and that
\verb'man' is a subclass of \verb'person', \snark\  will be able to prove
immediately that \verb'george' is a person, i.\  e., that
\begin{verbatim}
 (person george)
\end{verbatim}
This is rewritten as
\begin{verbatim}
 (instance-of george person)
\end{verbatim}

The proof is carried out simply by examining the declared sorts and objects,
without invoking any axioms.  Because \verb'man' is a subset of
\verb'person', any member of \verb'man' is also a member of \verb'person'.

It is possible to use the relation \verb'instance-of' to assert that a class,
rather than an individual, is a member of another class.  For instance, here
is a declaration of the class \verb'woman'.

\begin{verbatim}
  (defrelation woman
      "Collection of all women."
    (class woman)
    (instance-of woman biological-classification-type))
\end{verbatim}
The statement
\begin{verbatim}
  (instance-of woman biological-classification-type)
\end{verbatim}
says that the class of women is a biological classification type, a kind of
class.  This is quite different from saying that the class of women is a
subclass of the biological classification type---that would imply that every
woman is herself a class.


It is natural to make assertions about the properties of a class
as follows.
\begin{verbatim}
  (defrelation person
    (class person)
    (average-age person 70))
\end{verbatim}
The \verb'average-age' statement says something about the entire class of
people, not about individual members of the class.  If we really want to say
something about each element of the class, we can use the construct {\tt
template-slot-val}\-{\tt ue}, another standard relation name from the \okbc\
knowledge model:

\begin{verbatim}
  (defrelation person
    (class person)
    (template-slot-value ancestor person adam))
\end{verbatim}
Here
\begin{verbatim}
  (template-slot-value ancestor person adam)
\end{verbatim}
says that an ancestor of every person is Adam.  This
is equivalent to the following \snark\  assertion:
\begin{verbatim}
  (ancestor ?person adam)
\end{verbatim}

\subsubsection{Declaring Relations}
\label{subsec-kif-relations}

We have seen that when we declare a class we are simultaneously declaring a
unary predicate symbol, which stands for a unary relation.  Let us consider
the declaration of n-ary relations.

For example, suppose we want to declare a relation \verb'possesses', which
takes two arguments, a \verb'person' and an \verb'object'.  Then we may say
\begin{verbatim}
  (defrelation possesses
      "a ?person possesses an ?object if he or she owns it."
    (relation-arity possesses 2)
    (nth-domain possesses 1 person)
    (nth-domain possesses 2 object))
\end{verbatim}

An alternative, and equivalent, way to make the same declaration would
be
\begin{verbatim}
  (defrelation possesses
      "a ?person possesses an ?object if he or she owns it."
    (relation-arity possesses 2)
    (domain possesses person)
    (slot-value-type possesses  object))
\end{verbatim}


This last formulation is acceptable only for binary relations, of
arity 2.  The relation names \verb'domain', and \verb'slot-value-type'
are derived from the \okbc\   knowledge model.

The assertions involving the relations can be included in a
\verb'defobject' construct.
\begin{verbatim}
  (defobject the-maltese-falcon
      "the-maltese-falcon is an object possessed by George."
    (instance-of the-maltese-falcon object)
    (possesses george the-maltese-falcon))
\end{verbatim}

\label{subsubsec-subclasses}

There are many relations, for example, \verb'average-age', that apply
to classes.  The arguments of such relations are constant symbols that
represent classes.  While declaring such relations, the relevant
arguments should be restricted to be classes.  This can be accomplished
as follows.
\begin{verbatim}
  (defrelation average-age
      "Average age of the members of a collection of objects''
    (relation-arity average-age 2)
    (nth-domain-subclass-of average-age 1 physical-object)
    (nth-domain average-age 2 integer))
\end{verbatim}

The relation name \verb'nth-domain-subclass-of' restricts the first argument
to only those constant symbols that represent classes that are subclasses of
\verb'physical-object'.  The relation names {\tt range}-{\tt subclass}-{\tt
of}, {\tt slot}-{\tt value}-{\tt type}-{\tt subclass}-{\tt of} and {\tt
domain}-{\tt subclass}-{\tt of} may also be used.

To support the implementation of the type restriction when the
arguments of a relation are restricted to the constant symbols
representing classes, for every \kifsnark\  class, we automatically
declare a class of subclasses of that class.  For example, because we
have declared a class \verb'person', we declare
\verb'subclass-of-person' as a class as well.  Every \verb'subclass-of'
\verb'person' will be  an \verb'instance-of' \verb'subclass-of-person'.
Internally, \snark\  reduces the \verb'nth-domain-subclass-of'
restriction to an \verb'nth-domain' restriction on class of
subclasses.  For example,
\begin{verbatim}
    (nth-domain-subclass-of average-age 1 physical-object)
\end{verbatim}
is internally represented as
\begin{verbatim}
    (nth-domain average-age 1 subclass-of-physical-object)
\end{verbatim}

The objective of declaring the class of all subclasses was to take
advantage of the sort system in \snark\  to deal with meta-classes.
The sort names such as \verb'subclass-of-person' are not meant
to be visible to the user, and are outside the scope of \kifsnark.
It is, however, possible to use them while writing axioms. For example,
\snark\  will recognize \verb'?subclass-of-person' as a variable of sort
\verb'subclass-of-person'.  Quantification over classes is not a well
explored area for \kifsnark\  and is open for future research.

Any of the keyword arguments accepted by the \snark\  relation
declarations can be supplied through \kifsnark.  For example,
the following \snark\  declaration
\begin{verbatim}
  (declare-function-symbol 'mother 1
                           :rewrite-code 'mother-rewriter)
 \end{verbatim}
can be written in \kifsnark\  as follows:
\begin{verbatim}
  (deffunction mother
        (function-arity mother 1)
        (rewrite-code mother mother-rewriter))
 \end{verbatim}
The \snark\  keyword arguments are recognized as \kifsnark\  relation
names.

\subsubsection{Declaring Functions}
\label{subsec-kif-functions}

\Kif\  function declarations are similar to the relation declarations.  For
   example, suppose we want to declare the function \verb'mother', which
      takes a \verb'person' as its argument and yields a \verb'woman' as its
      value.   Then we may use the \kif\   construct
      \verb'deffunction', which is analogous to \verb'defrelation':
\begin{verbatim}
  (deffunction mother
      "the mother of a person."
    (function-arity mother 1)
    (nth-domain mother 1 person)
    (range mother woman)
    (parent (mother ?person) ?person))
\end{verbatim}

\subsubsection{Declaring Assertions}
\label{subsec-kif-assertions}

The assertion declaration is an extension to \kif\/, included to allow one to
make \snark\  assertions with \kif\  syntax, outside of declarations.
Assertions may be given a name and a documentation string.  For example, to
say that everyone has at most one spouse (at a given time), we can make the
assertion
\begin{samepage}
\begin{verbatim}
  (assertion
   (forall ((?x1 person)
            (?x2 person)
            (?x person))
           (=>
            (and (spouse ?x ?x1)
                 (spouse ?x ?x2))
            (= ?x1 ?x2)))
\end{verbatim}
\end{samepage}
\begin{verbatim}
   :name uniqueness-of-spouse
   :documentation
    "A person may have only one spouse at a time.")
\end{verbatim}
 Note that \snark\  accepts \kif\  syntax for logical symbols, such as
 \verb'=>' instead of
 \verb'implies'.  Also note that \kif\  does not have the convention
 that \verb'?person1' is a variable of sort \verb'person', say.
 Therefore we have spelled out explicitly the sort of each variable:
\begin{verbatim}
  (forall ((?x1 person)
           (?x2 person)
           (?x person)) ... )
\end{verbatim}

\Snark\   allows automatic coercion of variable types.  For example,
if the above assertion were written as
\begin{verbatim}
  (assertion
    (=>
     (and (spouse ?x ?x1)
          (spouse ?x ?x2))
     (= ?x1 ?x2))
   :name uniqueness-of-spouse
   :documentation
    "A person may have only one spouse at a time.")
\end{verbatim}
and the arguments of \verb`spouse` were declared to be of type
\verb`person`,
 \snark\ could automatically coerce {\tt ?x}, {\tt ?x1}, and {\tt ?x2} to be
of types \verb`person`.  To enable such automatic sort coercion, one select
the option {\tt use}-{\tt well}-{\tt sorting}.

The {\tt uniqueness-of-spouse} axiom can also be written as
\begin{verbatim}
  (assertion
    (=>
     (and (person ?x)
          (person ?x1)
          (person ?x2)
          (spouse ?x ?x1)
          (spouse ?x ?x2))
     (equal ?x1 ?x2))
   :name uniqueness-of-spouse
   :documentation
    "A person may have only one spouse at a time.")
\end{verbatim}

\paragraph{Exercise: Uniqueness of Mothers-in-law.}
\label{exec-mother-in-law}
Within the \kif\  extension of \snark\  introduce a relation
\verb'mother-in-law'.  Using your definition and the \kif\   family theory
introduced in this section, use \snark\  to prove that everyone has at most
one mother-in-law.

\subparagraph{Solution.}  The definition of a mother-in-law is given within
the \kif\  declaration
\begin{verbatim}
  (defrelation mother-in-law
      "?x1 is the mother-in-law of ?x2
       if ?x1 is the mother of the spouse of ?x2."
    (relation-arity mother-in-law 2)
    (domains mother-in-law person person)
    (forall ((?x1 person)
             (?x2 person)
             (?x person))
      (<=>
       (mother-in-law ?x1 ?x2)
       (exists ((?x person))
               (and
                (spouse ?x1 ?x)
                (equal ?x2 (mother ?x)))))))
\end{verbatim}

To prove the uniqueness of the mother-in-law, we give \snark\  the task
\begin{samepage}
\begin{verbatim}
  (prove '(forall ((?x1 person)
                   (?x2 person)
                   (?x person))
           (=>
            (and
             (mother-in-law ?x ?x1)
             (mother-in-law ?x ?x2))
            (equal ?x1 ?x2))))
\end{verbatim}
\end{samepage}

\subsection{Relationship of \kifsnark\  with \snark}

It is helpful to consider the equivalence between the \kifsnark\
constructs and the native \snark\  constructs.

In both \snark\  and \kif\, the same function and relation symbol may
occur with different arities.  However, in \snark\  there is no
assumption that the meaning of a symbol with arity 2, say, has any
relation at all to the meaning of the same symbol with arity 3.  In
\kif\/, on the other hand, the assumption is that if the same symbol
occurs with varying arity, all those occurrences stand for the same
function, and the function itself has variable arity.

For example, in \snark\  we could introduce a unary function \verb'minus' and
a binary function \verb'minus', without the idea that both of these are
instances of the same function.  In \kif\/, we would need to represent these
functions by different symbols.  If we talk about \verb'plus' with two
arguments in one place and three arguments in another in \kif\/, it is
understood that these are the same function.

 \Kif\  has two directions of implication connective, \verb'=>' and \verb'<=',
analogous to the \snark\/ \verb'implies' and \verb'implied-by'.  However,
while the \snark\  connectives accept exactly two arguments, the \kif\
connectives accept two or more.  The \kif\
\begin{verbatim}
  (=> <Form1> ... <Formn> <Form>)
\end{verbatim}
is equivalent to the \snark\
\begin{verbatim}
  (implies (and <Form1> ... <Formn>) <Form>)
\end{verbatim}
and the \kif\
\begin{verbatim}
  (<= <Form> <Form1> ... <Formn>)
\end{verbatim}
is equivalent to the \snark\
\begin{verbatim}
  (implied-by <Form> (and <Form1> ... <Formn>))
\end{verbatim}

The declaration
\begin{verbatim}
  (defrelation person
    (class person))
\end{verbatim}
makes the following declarations in \snark
\begin{itemize}
 \item the sort {\tt person}.

 \item a constant {\tt person}, which stands
 for the set of all people.

 \item a unary predicate symbol \verb'person', which stands for the relation
 that is true for people and false for other entities.
\end{itemize}
Thus the \kif\  \verb'class' declaration has more effects than the simple
 \snark\  declaration
\begin{verbatim}
   (declare-sort 'person)
\end{verbatim}

The following declaration
\begin{verbatim}
  (defrelation possesses
      "a ?person possesses an ?object if he or she owns it."
    (relation-arity possesses 2)
    (nth-domain possesses 1 person)
    (nth-domain possesses 2 object)
\end{verbatim}
is equivalent to the \snark\  declaration
\begin{verbatim}
  (declare-predicate-symbol 'possesses 2
    :sort '(boolean person object))
\end{verbatim}

\subsection{Built-in Number Sorts}
\label{sec:numbers}


\Snark\  has some built-in sorts of numbers.
The number sorts in \snark\  are based on the \ansi\   \kif\
specification. \Snark\  recognizes the following number sorts: \nnumber,
\complex, \real, \rational, \integer, \nnatural, \zero, \positive, \negative,
\odd, and \even.  The sort \nnumber\  is declared to be a subsort of \complex,
\real\   a subsort of \complex, \rational\  a subsort of \real,
and \integer\  a subsort of \rational.  The sort \real\   is partitioned
into three disjoint subsorts: \negative, \zero, and \positive.
The sort \integer  is partitioned into \even\  and \odd, with \zero\  included
as a subsort of \even.  The sort \nnatural\  comprises the
nonnegative integers.  To enable the automatic declaration of these
number sorts, one must select the option {\tt use}-{\tt number}-{\tt sorts}.


\Snark\/'s number sorts are based on those of \kif, which are based in turn
on \commonlisp's number types.

%%It is instructive to compare the \ansi\   \kif\   representation of numbers
%%with that of the Cyc ontology \cite{cyc-ul}.  The Cyc representation of
%%numbers explicitly includes \Real, \Rational, and \Integer, as well as
%%\PlusInfinity; it implicitly includes \Natural\  and \Zero. It does not
%%represent complex numbers.  In addition, the Cyc representation
%%includes as subclasses of the reals \NegativeNumber\  and
%%\NonNegativeNumber, and integer subclasses \NegativeInteger\
%%and \NonNegativeInteger\ (there are no such explicit subclasses for
%%the Rationals).  However, neither  \Real\  nor  \Integer\  is
%%explicitly partitioned into these two sets, nor does the integer
%%representation include the concept of even and odd numbers.



%\section{Abduction}
%\label{sec-abduction}
%\part{\Snark\  Reference Manual}
%\label{part-reference-manual}

\section*{Acknowledgments}

We are grateful for comments from Nikolaj Bjorner and Jose Meseguer.

The research reported here has been partly supported by DARPA under Contracts
N66001-97-C-8550 (HPKB) and N66001-97-8551-00-SC-01, Subcontract
PSRW-97-8551-00-SC-01 (Genoa).
\newpage
\label{bibliography}
\begin{thebibliography}{Chang and Lee}

 \bibitem[Allen]{allen} J. F. Allen, Time and Time Again:  The Many Ways
 to Represent Time, {\em International Journal of Intelligent Systems},
 Vol.\ 6, No.\ 4 (July 1991), pp.\ 341--355.

 \bibitem[Burckert]{burckert} H.-J. B\"urckert, {\em
A Resolution Principle for a Logic with Restricted Quantifiers},
Lecture Notes in Artificial Intelligence No. 568, Springer Verlag,
Berlin (1991).


 \bibitem[Chang]{chang} C. L. Chang and R. C. T. Lee, {\em
 Symbolic Logic and Mechanical Theorem Proving}, Academic Press, New
 York, NY (1973).

 \bibitem[Chaudhri]{okbc} V. K. Chaudhri, A. Farquhar, et al., {\sc
 Okbc}: A Programmatic Foundation for Knowledge Base Interoperability,
  {\em Proceedings of the AAAI-98}, Madison, WI (1998).

\bibitem[Dershowitz]{recursive-path} N. Dershowitz and
J.-P. Jouannaud, ``Rewrite Systems,'' in J. van Leeuwen (editor), {\em Handbook
of Theoretic Computer Science}, Elsevier, Amsterdam, The Netherlands
(1989), pp.\ 241--320.

\bibitem[Genesereth]{kif} M.\  R.\  Genesereth and R.\  E.\  Fikes, {\em Knowledge
Interchange Format, Version 3.0 Reference Manual}, (Logic-92-1) (1992).

 \bibitem[Graham]{ansi-commonlisp} P.\  Graham, {\em \ansi\   Common Lisp},
 Prentice Hall, Englewood Cliffs, NJ (1996).

 \bibitem[Lenat]{cyc} D.\  Lenat and R.\  V.\  Guha, {\em Building Large
  Knowledge Based Systems},  Addison-Wesley, Reading, MA (1990).  See also
%%  \htmladdnormallink {\tt http://www.cyc.com} %% uncomment for html
  {http://www.cyc.com}.

 \bibitem[Cyc-UL]{cyc-ul} D.\  Lenat, {\em Cyc Upper Ontology},
  See %% \htmladdnormallink {\tt http://www.cyc.com/cyc-2-1/index.html}
  {http://www.cyc.com/cyc-2-1/index.html}


 \bibitem[McCune]{otter} W.\   McCune, {\em Otter 3.0 User's Guide},
 Technical Report ANL-94/6, Argonne National Laboratory, Argonne, IL
 (1994).

 \bibitem[Manna]{manna} Z.\   Manna and R.\   Waldinger, {\em
 Deductive Foundations of Computer Programming}, Addison-Wesley,
 Reading, MA (1993).

 \bibitem[Waldinger]{waldinger} Z.\   Manna and R.\   Waldinger,
 ``Fundamentals of Deductive Program Synthesis,'' {\em IEEE
 Transactions on Software Engineering,} Vol. 18, No. 8 (August 1992),
 pp.\  674--704.

 \bibitem[Pitman]{commonlisp-hyperspec} K.\   Pitman, {\em Common Lisp
 HyperSpec}, Harlequin Group, Cambridge, UK (1996).

\end{thebibliography}

\end{document}

For example, in our problem of the
red-headed grandmother (Section \ref{subsec-conditional-answers}), we
were able to construct a conditional answer because we chose to
represent red-headedness as a predicate symbol, not as a sort.
Otherwise, we would not have been able to do a case analysis on
whether or not a person was red-headed or not.




_____



_______________

